You will help plan and design a new feature addition to an existing React/Tailwind codebase. You
will receive information about the existing features, the new feature request, and any technical
constraints. Your goal is to provide a detailed, structured response that outlines how to implement
this feature while maintaining consistency with the existing codebase.

First, review the existing code:
<existing_code>
<file_tree>
/Users/petercorreia/workspace/updated_acquire_dashboard
├── .cursorignore
├── .babelrc
├── index.html
├── tailwind.config.js
├── tsconfig.app.json
├── Screenshot 2024-09-12 at 12.06.51 PM.png
├── jest.setup.js
├── jest.config.js
├── vite.config.js
├── test-report.html
├── .cursorrules
├── fileMock.js
├── README.md
├── claudeDev_docs
├── ├── Dashboard_Improvements.md
├── ├── TestCoverageSummary.md
├── ├── FailingTestCases.md
├── ├── IntegrationTestingGuide.md
├── ├── TestingStrategy.md
├── ├── currentTask.md
├── └── FilterComponentTestPlan.md
├── Screenshot 2024-09-16 at 10.12.28 AM.png
├── Screenshot 2024-09-10 at 10.08.27 AM.png
├── public
├── └── favicon.svg
├── Screenshot 2024-09-10 at 6.57.11 AM.png
├── .replit
├── package.json
├── Scratch_Pad
├── ├── meta_feature_prompt
├── ├── feature_xml_output
├── └── feature_prompt_with_code_to_llm
├── components.json
├── tsconfig.json
├── Screenshot 2024-09-12 at 7.11.02 AM.png
├── postcss.config.js
├── Screenshot 2024-09-16 at 10.12.20 AM.png
├── Screenshot 2024-09-13 at 4.40.24 PM.png
└── src
└── ├── context
└── ├── ├── DashboardContext.test.jsx
└── ├── └── DashboardContext.jsx
└── ├── testReporters
└── ├── └── failingTestReporter.js
└── ├── App.css
└── ├── index.css
└── ├── components
└── ├── ├── ui
└── ├── ├── ├── card.tsx
└── ├── ├── ├── slider.tsx
└── ├── ├── ├── chart.tsx
└── ├── ├── ├── table.tsx
└── ├── ├── ├── tooltip.jsx
└── ├── ├── ├── button.tsx
└── ├── ├── ├── select.tsx
└── ├── ├── ├── input.tsx
└── ├── ├── └── skeleton.tsx
└── ├── ├── VirtualRow.jsx
└── ├── ├── FileList.jsx
└── ├── ├── MultiFileUpload.jsx
└── ├── ├── Filter.jsx
└── ├── ├── FileUpload.jsx
└── ├── ├── ErrorBoundary.jsx
└── ├── ├── SummaryStatistics.jsx
└── ├── ├── ProfitVsPriceChart.jsx
└── ├── ├── RevenueVsPriceChart.test.jsx
└── ├── ├── StartupDetailsTable.test.jsx
└── ├── ├── Filter.test.jsx
└── ├── ├── Sidebar.jsx
└── ├── ├── Dashboard.jsx
└── ├── ├── test_file.txt
└── ├── ├── Dashboard.test.jsx
└── ├── ├── SummaryStatistics.test.jsx
└── ├── ├── RangeFilter.jsx
└── ├── ├── TableHeader.jsx
└── ├── ├── FileUpload.test.jsx
└── ├── ├── Pagination.jsx
└── ├── ├── RangeFilter.test.jsx
└── ├── ├── ProfitVsPriceChart.test.jsx
└── ├── ├── LazyChart.jsx
└── ├── ├── StartupDetailsTable.jsx
└── ├── ├── FileManagementContainer.jsx
└── ├── ├── FileManagement.jsx
└── ├── ├── RevenueVsPriceChart.jsx
└── ├── ├── ErrorBoundary.test.jsx
└── ├── └── VirtualTable.jsx
└── ├── __tests__
└── ├── ├── StatePersistence.test.jsx
└── ├── ├── PerformanceTests.test.jsx
└── ├── ├── CrossComponentDataFlow.test.jsx
└── ├── ├── ConcurrentActions.test.jsx
└── ├── ├── FileUploadFilterIntegration.test.jsx
└── ├── ├── EdgeCasesAndErrors.test.jsx
└── ├── └── UserWorkflow.test.jsx
└── ├── hooks
└── ├── ├── useDebounce.js
└── ├── ├── useChartData.js
└── ├── └── useTableData.js
└── ├── App.jsx
└── ├── lib
└── ├── ├── utils.ts
└── ├── └── errorLogger.js
└── └── index.jsx
</file_tree>

<file_contents>
File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/context/DashboardContext.test.jsx
```jsx
import React, { useContext } from 'react';
import { render, screen, fireEvent, act } from '@testing-library/react';
import '@testing-library/jest-dom';
import { DashboardContext, DashboardProvider } from './DashboardContext';

const TestComponent = () => {
  const context = useContext(DashboardContext);
  return (
    <div>
      <div data-testid="filters">{JSON.stringify(context.filters)}</div>
      <div data-testid="data">{JSON.stringify(context.data)}</div>
      <div data-testid="hasUploadedData">{context.hasUploadedData.toString()}</div>
      <button onClick={() => context.setFilters({ ...context.filters, businessType: 'Tech' })}>
        Update Filters
      </button>
      <button onClick={() => context.setData([{ id: 1, name: 'Test' }])}>
        Update Data
      </button>
      <button onClick={() => context.removeListingFromData(0)}>
        Remove Listing
      </button>
      <button onClick={() => context.setData([
        { 'TTM Revenue': 5000000, 'TTM Profit': 1000000, 'Asking Price': 20000000 },
        { 'TTM Revenue': 8000000, 'TTM Profit': 2000000, 'Asking Price': 30000000 },
      ])}>
        Set New Data
      </button>
    </div>
  );
};

describe('DashboardContext', () => {
  test('renders provider without crashing', () => {
    render(
      <DashboardProvider>
        <div>Test</div>
      </DashboardProvider>
    );
  });

  test('provides default values', () => {
    render(
      <DashboardProvider>
        <TestComponent />
      </DashboardProvider>
    );

    const filtersElement = screen.getByTestId('filters');
    expect(filtersElement).toHaveTextContent('"businessType":"all"');
    expect(filtersElement).toHaveTextContent('"revenue":[0,10000000]');
    expect(filtersElement).toHaveTextContent('"profit":[0,10000000]');
    expect(filtersElement).toHaveTextContent('"price":[0,100000000]');

    const dataElement = screen.getByTestId('data');
    expect(dataElement).toHaveTextContent('[]');

    const hasUploadedDataElement = screen.getByTestId('hasUploadedData');
    expect(hasUploadedDataElement).toHaveTextContent('false');
  });

  test('updates filters', () => {
    render(
      <DashboardProvider>
        <TestComponent />
      </DashboardProvider>
    );

    fireEvent.click(screen.getByText('Update Filters'));

    const filtersElement = screen.getByTestId('filters');
    expect(filtersElement).toHaveTextContent('"businessType":"Tech"');
  });

  test('updates data and hasUploadedData', () => {
    render(
      <DashboardProvider>
        <TestComponent />
      </DashboardProvider>
    );

    fireEvent.click(screen.getByText('Update Data'));

    const dataElement = screen.getByTestId('data');
    expect(dataElement).toHaveTextContent('[{"id":1,"name":"Test"}]');

    const hasUploadedDataElement = screen.getByTestId('hasUploadedData');
    expect(hasUploadedDataElement).toHaveTextContent('true');
  });

  test('removes listing from data', () => {
    render(
      <DashboardProvider>
        <TestComponent />
      </DashboardProvider>
    );

    // First, add some data
    fireEvent.click(screen.getByText('Update Data'));

    // Then remove the listing
    fireEvent.click(screen.getByText('Remove Listing'));

    const dataElement = screen.getByTestId('data');
    expect(dataElement).toHaveTextContent('[]');

    const hasUploadedDataElement = screen.getByTestId('hasUploadedData');
    expect(hasUploadedDataElement).toHaveTextContent('false');
  });

  test('updates filter ranges when new data is set', () => {
    render(
      <DashboardProvider>
        <TestComponent />
      </DashboardProvider>
    );

    fireEvent.click(screen.getByText('Set New Data'));

    const filtersElement = screen.getByTestId('filters');
    expect(filtersElement).toHaveTextContent('"revenue":[5000000,8000000]');
    expect(filtersElement).toHaveTextContent('"profit":[1000000,2000000]');
    expect(filtersElement).toHaveTextContent('"price":[20000000,30000000]');
  });
});
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/context/DashboardContext.jsx
```jsx
import React, { createContext, useState, useCallback, useMemo, useEffect } from 'react';

/**
 * DashboardContext provides global state for the dashboard and file management.
 * 
 * Changes made:
 * - Removed single selectedFileId; replaced with selectedFileIds (array).
 * - Data now aggregates from all selected files.
 * - Added isLoadingData to handle loading states when selection changes.
 * - Updated logic in useEffect to handle multiple file selections.
 */

export const DashboardContext = createContext();

export const DashboardProvider = ({ children }) => {
  const [files, setFiles] = useState([]);
  const [selectedFileIds, setSelectedFileIds] = useState([]);

  // Filters and ranges
  const [filters, setFilters] = useState({
    revenue: [0, 0],
    profit: [0, 0],
    price: [0, 0],
    businessType: 'all',
  });

  const [filterRanges, setFilterRanges] = useState({
    revenue: [0, 0],
    profit: [0, 0],
    price: [0, 0],
  });

  const [isLoadingData, setIsLoadingData] = useState(false);

  const updateFilterRanges = useCallback((data) => {
    if (!data || data.length === 0) return;

    const getNumeric = (item, key) => Number(item[key]) || 0;

    const minRevenue = Math.min(...data.map(d => getNumeric(d, 'TTM Revenue')));
    const maxRevenue = Math.max(...data.map(d => getNumeric(d, 'TTM Revenue')));
    const minProfit = Math.min(...data.map(d => getNumeric(d, 'TTM Profit')));
    const maxProfit = Math.max(...data.map(d => getNumeric(d, 'TTM Profit')));
    const minPrice = Math.min(...data.map(d => getNumeric(d, 'Asking Price')));
    const maxPrice = Math.max(...data.map(d => getNumeric(d, 'Asking Price')));

    setFilterRanges({
      revenue: [minRevenue, maxRevenue],
      profit: [minProfit, maxProfit],
      price: [minPrice, maxPrice]
    });

    // Reset filters to full range if needed (if initial upload)
    setFilters(prevFilters => {
      const updated = { ...prevFilters };
      if (prevFilters.revenue[0] === 0 && prevFilters.revenue[1] === 0) {
        updated.revenue = [minRevenue, maxRevenue];
      }
      if (prevFilters.profit[0] === 0 && prevFilters.profit[1] === 0) {
        updated.profit = [minProfit, maxProfit];
      }
      if (prevFilters.price[0] === 0 && prevFilters.price[1] === 0) {
        updated.price = [minPrice, maxPrice];
      }
      return updated;
    });
  }, []);

  // Derive selected files
  const selectedFiles = useMemo(() => {
    return files.filter(file => selectedFileIds.includes(file.id));
  }, [files, selectedFileIds]);

  // Aggregated data from all selected files
  const data = useMemo(() => {
    if (selectedFiles.length === 0) return [];
    return selectedFiles.reduce((acc, file) => {
      if (file.data && Array.isArray(file.data)) {
        return acc.concat(file.data);
      }
      return acc;
    }, []);
  }, [selectedFiles]);

  const hasUploadedData = files.length > 0;

  // Derive business types
  const businessTypes = useMemo(() => {
    if (!hasUploadedData || data.length === 0) return ['all'];
    const types = new Set();
    data.forEach(item => {
      if (item['Business Type']) {
        types.add(item['Business Type']);
      }
    });
    return ['all', ...Array.from(types)];
  }, [data, hasUploadedData]);

  // Handle updates when selected files change
  useEffect(() => {
    if (selectedFileIds.length === 0) {
      // No files selected, reset filters to defaults
      setFilters({
        revenue: [0, 0],
        profit: [0, 0],
        price: [0, 0],
        businessType: 'all',
      });
      return;
    }

    setIsLoadingData(true);
    // Simulate async update if needed. Here we just update immediately.
    Promise.resolve().then(() => {
      updateFilterRanges(data);
      setIsLoadingData(false);
    });
  }, [selectedFileIds, data, updateFilterRanges]);

  return (
    <DashboardContext.Provider
      value={{
        files,
        setFiles,
        selectedFileIds,
        setSelectedFileIds,
        data,
        filters,
        setFilters,
        filterRanges,
        updateFilterRanges,
        hasUploadedData,
        businessTypes,
        isLoadingData
      }}
    >
      {children}
    </DashboardContext.Provider>
  );
};
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/VirtualRow.jsx
```jsx
import React from 'react';
import { Trash2, ExternalLink } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { formatCurrency, calculateFinancialRatio } from "@/lib/utils";

const VirtualRow = React.memo(({ index, style, data, onRemove }) => {
  const item = data[index];
  if (!item) return null;

  return (
    <div style={style} className={`flex ${index % 2 === 0 ? 'bg-gray-50' : ''}`}>
      <div className="flex-1 px-4 py-2">{item['Business Type']}</div>
      <div className="flex-1 px-4 py-2 text-right">{formatCurrency(item['TTM Revenue'])}</div>
      <div className="flex-1 px-4 py-2 text-right">{formatCurrency(item['TTM Profit'])}</div>
      <div className="flex-1 px-4 py-2 text-right">{formatCurrency(item['Asking Price'])}</div>
      <div className="flex-1 px-4 py-2 text-right">
        {calculateFinancialRatio(item['Asking Price'], item['TTM Revenue'])}
      </div>
      <div className="flex-1 px-4 py-2 text-right">
        {calculateFinancialRatio(item['Asking Price'], item['TTM Profit'])}
      </div>
      <div className="flex-1 px-4 py-2">
        <a href={item['marketplace-card href']} target="_blank" rel="noopener noreferrer">
          <ExternalLink className="h-4 w-4" />
        </a>
      </div>
      <div className="flex-1 px-4 py-2">
        <Button variant="ghost" size="sm" onClick={() => onRemove(item.id)}>
          <Trash2 className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
});

VirtualRow.displayName = 'VirtualRow';

export default VirtualRow;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/FileList.jsx
```jsx
import React from 'react';
import { Trash2 } from 'lucide-react';

/**
 * Updated to include checkboxes for multiple file selection.
 * Props:
 *  - files: array of {id, name, data, metadata}
 *  - selectedFileIds: array of currently selected file IDs
 *  - onToggleFileSelection: (id: string) => void
 *  - onDeleteFile: (id: string) => void
 */

const FileList = ({ files, selectedFileIds, onToggleFileSelection, onDeleteFile }) => {
    return (
        <div className="w-full md:w-1/4 border-r border-gray-200 p-2 space-y-2">
            <h2 className="font-bold text-lg">Uploaded Files</h2>
            {files.length === 0 ? (
                <p className="text-gray-500 text-sm">No files uploaded yet.</p>
            ) : (
                <ul className="space-y-1">
                    {files.map(file => {
                        const isSelected = selectedFileIds.includes(file.id);
                        return (
                            <li
                                key={file.id}
                                className={`flex items-center justify-between p-2 rounded hover:bg-gray-100 space-x-2 ${isSelected ? 'bg-blue-50' : ''
                                    }`}
                            >
                                <input
                                    type="checkbox"
                                    className="form-checkbox h-4 w-4 text-blue-600"
                                    checked={isSelected}
                                    onChange={() => onToggleFileSelection(file.id)}
                                />
                                <span className="font-medium truncate flex-grow">{file.name}</span>
                                <button
                                    className="text-red-500 hover:text-red-700"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        onDeleteFile(file.id);
                                    }}
                                >
                                    <Trash2 className="w-4 h-4" />
                                </button>
                            </li>
                        );
                    })}
                </ul>
            )}
        </div>
    );
};

export default FileList;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/MultiFileUpload.jsx
```jsx
// MultiFileUpload.jsx
import React, { useState, useRef } from 'react';
import Papa from 'papaparse';

const MultiFileUpload = ({ onFilesUploaded }) => {
    const [localFiles, setLocalFiles] = useState([]);
    const [error, setError] = useState(null);
    const [uploading, setUploading] = useState(false);
    const [progress, setProgress] = useState(0);
    const fileInputRef = useRef(null);

    const handleFileSelect = (e) => {
        const files = Array.from(e.target.files);
        setLocalFiles(files);
        setError(null);
    };

    const handleDrop = (e) => {
        e.preventDefault();
        const files = Array.from(e.dataTransfer.files);
        setLocalFiles(files);
        setError(null);
    };

    const handleDragOver = (e) => e.preventDefault();

    const handleUpload = async () => {
        if (localFiles.length === 0) return;
        setUploading(true);
        setError(null);
        try {
            const parsedFiles = [];
            for (let i = 0; i < localFiles.length; i++) {
                const file = localFiles[i];
                if (file.type !== 'text/csv' && file.name.slice(-4) !== '.csv') {
                    throw new Error(`Unsupported file type for ${file.name}. Only CSV allowed.`);
                }
                const data = await parseCSV(file);
                parsedFiles.push({
                    id: `${file.name}-${file.lastModified}`,
                    name: file.name,
                    data,
                    metadata: {
                        size: file.size,
                        lastModified: file.lastModified
                    }
                });
                setProgress(Math.round(((i + 1) / localFiles.length) * 100));
            }
            onFilesUploaded(parsedFiles);
            setLocalFiles([]);
        } catch (err) {
            console.error(err);
            setError(err.message);
        } finally {
            setUploading(false);
        }
    };

    const parseCSV = (file) => {
        return new Promise((resolve, reject) => {
            Papa.parse(file, {
                complete: results => {
                    if (results.errors.length > 0) {
                        reject(new Error(`Error parsing ${file.name}: ${results.errors[0].message}`));
                    } else {
                        resolve(results.data);
                    }
                },
                error: (err) => reject(err),
                header: true,
                skipEmptyLines: true
            });
        });
    };

    return (
        <div className="p-4">
            <div
                className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer"
                onDrop={handleDrop}
                onDragOver={handleDragOver}
                onClick={() => fileInputRef.current.click()}
            >
                <input
                    ref={fileInputRef}
                    type="file"
                    multiple
                    accept=".csv"
                    className="hidden"
                    onChange={handleFileSelect}
                />
                <p className="text-lg mb-2">Click to upload or drag and drop</p>
                <p className="text-sm text-gray-500">CSV files only, max size ~50MB</p>
            </div>
            {error && <p className="mt-4 text-red-500">{error}</p>}
            {localFiles.length > 0 && (
                <ul className="mt-4 list-disc pl-5 space-y-1 text-sm text-gray-700">
                    {localFiles.map((f, idx) => <li key={idx}>{f.name}</li>)}
                </ul>
            )}
            {uploading && (
                <div className="mt-4">
                    <div className="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
                        <div
                            className="bg-blue-600 h-2.5 rounded-full"
                            style={{ width: `${progress}%` }}
                        ></div>
                    </div>
                    <p className="text-center mt-2">{progress}% Uploaded</p>
                </div>
            )}
            <button
                className="mt-4 bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 disabled:bg-gray-400"
                onClick={handleUpload}
                disabled={localFiles.length === 0 || uploading}
            >
                {uploading ? 'Uploading...' : 'Upload Files'}
            </button>
        </div>
    );
};

export default MultiFileUpload;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/Filter.jsx
```jsx
import React, { useState, useEffect, useContext, useMemo } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { HelpCircle, X } from 'lucide-react';
import { Tooltip } from "@/components/ui/tooltip";
import { Skeleton } from "@/components/ui/skeleton";
import RangeFilter from './RangeFilter';
import { DashboardContext } from '../context/DashboardContext';
import { useDebounce } from '../hooks/useDebounce';

const Filter = () => {
  const [activeTooltip, setActiveTooltip] = useState(null);
  const [activeFilters, setActiveFilters] = useState({});
  const [isLoading, setIsLoading] = useState(false);
  const { filters, setFilters, filterRanges, hasUploadedData, businessTypes } = useContext(DashboardContext);

  const debouncedSetFilters = useDebounce(setFilters, 300);

  useEffect(() => {
    const newActiveFilters = {};
    Object.entries(filters).forEach(([key, value]) => {
      if (Array.isArray(value) && (value[0] > filterRanges[key][0] || value[1] < filterRanges[key][1])) {
        newActiveFilters[key] = true;
      } else if (key === 'businessType' && value !== 'all') {
        newActiveFilters[key] = true;
      }
    });
    setActiveFilters(newActiveFilters);
  }, [filters, filterRanges]);

  const handleFilterChange = (key, newValue) => {
    setIsLoading(true);
    debouncedSetFilters(prevFilters => {
      setIsLoading(false);
      return { ...prevFilters, [key]: newValue };
    });
  };

  const handleResetFilter = (key) => {
    const resetValue = key === 'businessType' ? 'all' : filterRanges[key];
    handleFilterChange(key, resetValue);
  };

  const resetAllFilters = () => {
    setFilters({
      revenue: filterRanges.revenue,
      profit: filterRanges.profit,
      price: filterRanges.price,
      businessType: 'all',
    });
  };

  const generatePresets = (key) => {
    const [min, max] = filterRanges[key];
    const range = max - min;
    return [
      { label: `${min} - ${Math.round(min + range * 0.25)}`, min: min, max: Math.round(min + range * 0.25) },
      { label: `${Math.round(min + range * 0.25)} - ${Math.round(min + range * 0.5)}`, min: Math.round(min + range * 0.25), max: Math.round(min + range * 0.5) },
      { label: `${Math.round(min + range * 0.5)} - ${Math.round(min + range * 0.75)}`, min: Math.round(min + range * 0.5), max: Math.round(min + range * 0.75) },
      { label: `${Math.round(min + range * 0.75)} - ${max}`, min: Math.round(min + range * 0.75), max: max },
    ];
  };

  if (!hasUploadedData) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Filters</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex flex-col items-center justify-center h-64">
            <h3 className="text-xl font-semibold mb-2">No Data to Display</h3>
            <p className="text-gray-600 mb-4">Upload data from the File Management page to see available filters.</p>
          </div>
        </CardContent>
      </Card>
    );
  }

  // Count how many filters are active
  const activeFilterCount = Object.keys(activeFilters).length;

  return (
    <Card>
      <CardHeader>
        <div className="flex justify-between items-center w-full">
          <div className="flex flex-col space-y-1">
            <CardTitle className="flex items-center space-x-2">
              <span>Filters</span>
              {activeFilterCount > 0 && (
                <span className="text-sm text-blue-600 bg-blue-100 px-2 py-0.5 rounded-full">
                  {activeFilterCount} active {activeFilterCount === 1 ? 'filter' : 'filters'}
                </span>
              )}
              {activeFilterCount === 0 && (
                <span className="text-sm text-gray-500">No active filters</span>
              )}
            </CardTitle>
          </div>
          <Button onClick={resetAllFilters} variant="outline" size="sm">
            Reset All Filters
          </Button>
        </div>
      </CardHeader>
      <CardContent>
        <div className="space-y-8">
          <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">

            {/* Revenue Filter */}
            <div className="space-y-2">
              <div className="h-8 flex items-center justify-between">
                <h3 className="text-sm font-medium text-gray-700 flex items-center flex-1">
                  <span className="flex-grow capitalize flex items-center space-x-1">
                    <span>Revenue</span>
                    {activeFilters.revenue && <span className="inline-block w-2 h-2 rounded-full bg-blue-500"></span>}
                  </span>
                  <Tooltip content="Adjust this slider to display startups within a certain revenue range. You can drag the handles, type exact values, or use preset ranges.">
                    <HelpCircle className="w-4 h-4 text-gray-400 cursor-help ml-2" />
                  </Tooltip>
                  <div className="w-8 h-8 flex items-center justify-center">
                    {activeFilters.revenue && (
                      <Button
                        variant="outline"
                        size="sm"
                        className="px-1 py-0 bg-red-100 hover:bg-red-200 text-red-600"
                        onClick={() => handleResetFilter('revenue')}
                      >
                        <X className="h-4 w-4" />
                      </Button>
                    )}
                  </div>
                </h3>
              </div>
              <div className="min-h-[180px]">
                {isLoading ? (
                  <Skeleton className="h-[180px]" />
                ) : (
                  <RangeFilter
                    label="Revenue Range"
                    min={filterRanges.revenue[0]}
                    max={filterRanges.revenue[1]}
                    value={filters.revenue}
                    onChange={(value) => handleFilterChange('revenue', value)}
                    presets={generatePresets('revenue')}
                  />
                )}
              </div>
            </div>

            {/* Profit Filter */}
            <div className="space-y-2">
              <div className="h-8 flex items-center justify-between">
                <h3 className="text-sm font-medium text-gray-700 flex items-center flex-1">
                  <span className="flex-grow capitalize flex items-center space-x-1">
                    <span>Profit</span>
                    {activeFilters.profit && <span className="inline-block w-2 h-2 rounded-full bg-blue-500"></span>}
                  </span>
                  <Tooltip content="Filter startups by profit range. Narrow down the displayed results by setting minimum and maximum profit values, or select a preset range.">
                    <HelpCircle className="w-4 h-4 text-gray-400 cursor-help ml-2" />
                  </Tooltip>
                  <div className="w-8 h-8 flex items-center justify-center">
                    {activeFilters.profit && (
                      <Button
                        variant="outline"
                        size="sm"
                        className="px-1 py-0 bg-red-100 hover:bg-red-200 text-red-600"
                        onClick={() => handleResetFilter('profit')}
                      >
                        <X className="h-4 w-4" />
                      </Button>
                    )}
                  </div>
                </h3>
              </div>
              <div className="min-h-[180px]">
                {isLoading ? (
                  <Skeleton className="h-[180px]" />
                ) : (
                  <RangeFilter
                    label="Profit Range"
                    min={filterRanges.profit[0]}
                    max={filterRanges.profit[1]}
                    value={filters.profit}
                    onChange={(value) => handleFilterChange('profit', value)}
                    presets={generatePresets('profit')}
                  />
                )}
              </div>
            </div>

            {/* Price Filter */}
            <div className="space-y-2">
              <div className="h-8 flex items-center justify-between">
                <h3 className="text-sm font-medium text-gray-700 flex items-center flex-1">
                  <span className="flex-grow capitalize flex items-center space-x-1">
                    <span>Price</span>
                    {activeFilters.price && <span className="inline-block w-2 h-2 rounded-full bg-blue-500"></span>}
                  </span>
                  <Tooltip content="Set the asking price range for startups. Use the slider, enter exact values, or pick a preset to quickly filter the displayed startups.">
                    <HelpCircle className="w-4 h-4 text-gray-400 cursor-help ml-2" />
                  </Tooltip>
                  <div className="w-8 h-8 flex items-center justify-center">
                    {activeFilters.price && (
                      <Button
                        variant="outline"
                        size="sm"
                        className="px-1 py-0 bg-red-100 hover:bg-red-200 text-red-600"
                        onClick={() => handleResetFilter('price')}
                      >
                        <X className="h-4 w-4" />
                      </Button>
                    )}
                  </div>
                </h3>
              </div>
              <div className="min-h-[180px]">
                {isLoading ? (
                  <Skeleton className="h-[180px]" />
                ) : (
                  <RangeFilter
                    label="Price Range"
                    min={filterRanges.price[0]}
                    max={filterRanges.price[1]}
                    value={filters.price}
                    onChange={(value) => handleFilterChange('price', value)}
                    presets={generatePresets('price')}
                  />
                )}
              </div>
            </div>
          </div>
          <div className="space-y-2">
            <div className="h-8 flex items-center justify-between">
              <h3 className="text-sm font-medium text-gray-700 flex items-center flex-1">
                <span className="flex-grow flex items-center space-x-1">
                  <span>Business Type</span>
                  {activeFilters.businessType && <span className="inline-block w-2 h-2 rounded-full bg-blue-500"></span>}
                </span>
                <Tooltip content="Filter startups by their business type. Select 'All' or choose a specific category to narrow your results.">
                  <HelpCircle className="w-4 h-4 text-gray-400 cursor-help ml-2" />
                </Tooltip>
                <div className="w-8 h-8 flex items-center justify-center">
                  {activeFilters.businessType && (
                    <Button
                      variant="outline"
                      size="sm"
                      className="px-1 py-0 bg-red-100 hover:bg-red-200 text-red-600"
                      onClick={() => handleResetFilter('businessType')}
                    >
                      <X className="h-4 w-4" />
                    </Button>
                  )}
                </div>
              </h3>
            </div>
            <div className="min-h-[40px]">
              {isLoading ? (
                <Skeleton className="h-10" />
              ) : (
                <Select
                  value={filters.businessType}
                  onValueChange={(value) => handleFilterChange('businessType', value)}
                >
                  <SelectTrigger className="w-full">
                    <SelectValue placeholder="Select a business type" />
                  </SelectTrigger>
                  <SelectContent>
                    {businessTypes.map((type) => (
                      <SelectItem key={type} value={type}>
                        {type === 'all' ? 'All' : type}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              )}
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

export default Filter;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/FileUpload.jsx
```jsx
import React, { useState } from 'react';
import { Button } from './ui/button';
import { Card } from './ui/card';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from './ui/table';
import Papa from 'papaparse';

const FileUpload = ({ onUpload }) => {
  const [files, setFiles] = useState([]);
  const [uploading, setUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [uploadedFiles, setUploadedFiles] = useState([]);
  const [error, setError] = useState(null);

  const handleFileChange = (event) => {
    setFiles(Array.from(event.target.files));
    setError(null);
  };

  const handleDrop = (event) => {
    event.preventDefault();
    setFiles(Array.from(event.dataTransfer.files));
    setError(null);
  };

  const handleDragOver = (event) => {
    event.preventDefault();
  };

  const processCSV = (file) => {
    return new Promise((resolve, reject) => {
      Papa.parse(file, {
        complete: (results) => {
          resolve(results.data);
        },
        error: (error) => {
          reject(error);
        },
        header: true,
        skipEmptyLines: true,
      });
    });
  };

  const handleUpload = async () => {
    setUploading(true);
    setUploadProgress(0);
    setError(null);

    try {
      const processedData = [];
      let lastFileMetadata = null;

      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        setUploadProgress(Math.round((i / files.length) * 100));

        if (file.type === 'text/csv') {
          const data = await processCSV(file);
          processedData.push(...data);

          lastFileMetadata = {
            name: file.name,
            type: file.type,
            size: file.size,
            lastModified: file.lastModified,
          };
        } else {
          throw new Error(`Unsupported file type: ${file.type}. Please upload CSV files only.`);
        }
      }

      const newUploadedFile = {
        name: lastFileMetadata.name,
        dateUploaded: new Date().toLocaleDateString(),
        lastUpdated: new Date().toLocaleDateString(),
        uploadedBy: 'Current User',
      };

      setUploadedFiles((prev) => [...prev, newUploadedFile]);
      await onUpload(processedData, lastFileMetadata);

      setUploadProgress(100);
      await new Promise((resolve) => setTimeout(resolve, 1000));
      setUploading(false);
      setFiles([]);
    } catch (error) {
      console.error('Upload error:', error);
      setError(error.message);
      setUploading(false);
    }
  };

  return (
    <div>
      <div
        className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer"
        onDrop={handleDrop}
        onDragOver={handleDragOver}
        onClick={() => document.getElementById('fileInput').click()}
      >
        <input
          data-testid="file-input"
          id="fileInput"
          type="file"
          multiple
          accept=".csv"
          onChange={handleFileChange}
          className="hidden"
        />
        <p className="text-lg mb-2">Click to upload or drag and drop</p>
        <p className="text-sm text-gray-500">CSV files only, maximum file size 50 MB</p>
      </div>
      {error && <p className="mt-4 text-red-500">{error}</p>}
      {files.length > 0 && (
        <div className="mt-4">
          <h3 className="font-semibold mb-2">Selected files:</h3>
          <ul className="list-disc pl-5">
            {files.map((file, index) => (
              <li key={index}>{file.name}</li>
            ))}
          </ul>
        </div>
      )}
      {uploading && (
        <div className="mt-4">
          <div className="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
            <div className="bg-blue-600 h-2.5 rounded-full" style={{ width: `${uploadProgress}%` }}></div>
          </div>
          <p className="text-center mt-2">{uploadProgress}% Uploaded</p>
        </div>
      )}
      <Button className="mt-4" onClick={handleUpload} disabled={files.length === 0 || uploading} data-testid="upload-button">
        {uploading ? 'Uploading...' : 'Upload File'}
      </Button>
      {uploadedFiles.length > 0 && (
        <Table className="mt-8">
          <TableHeader>
            <TableRow>
              <TableHead>File name</TableHead>
              <TableHead>Date uploaded</TableHead>
              <TableHead>Last updated</TableHead>
              <TableHead>Uploaded by</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {uploadedFiles.map((file, index) => (
              <TableRow key={index}>
                <TableCell>{file.name}</TableCell>
                <TableCell>{file.dateUploaded}</TableCell>
                <TableCell>{file.lastUpdated}</TableCell>
                <TableCell>{file.uploadedBy}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      )}
    </div>
  );
};

export default FileUpload;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/SummaryStatistics.jsx
```jsx
import React from 'react';
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { formatCurrency } from "@/lib/utils";

const SummaryStatistics = ({ averageMetrics, hasUploadedData }) => {
  console.log('SummaryStatistics rendered with:', { averageMetrics, hasUploadedData });

  const renderMetric = (key, value) => {
    console.log(`Rendering metric: ${key} = ${value}`);
    return (
      <div key={key}>
        <p className="text-sm font-medium text-gray-500">{`Avg ${key.replace('avg', '')}`}</p>
        <p className="mt-1 text-2xl sm:text-3xl font-semibold text-gray-900">
          {key.includes('PriceTo')
            ? value // Already formatted in Dashboard.jsx
            : typeof value === 'number'
              ? formatCurrency(value)
              : value || 'N/A'}
        </p>
      </div>
    );
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>
          Summary Statistics
        </CardTitle>
      </CardHeader>
      <CardContent className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4">
        {!hasUploadedData ? (
          <div className="flex flex-col items-center justify-center h-64 col-span-full">
            <h3 className="text-xl font-semibold mb-2">No Data Available</h3>
            <p className="text-gray-600 mb-4">Upload data from the File Management page to see summary statistics.</p>
          </div>
        ) : (
          <>
            {averageMetrics && typeof averageMetrics === 'object' ? (
              Object.entries(averageMetrics).map(([key, value]) => renderMetric(key, value))
            ) : (
              <div className="col-span-full">
                <p>No metrics available</p>
              </div>
            )}
          </>
        )}
      </CardContent>
    </Card>
  );
};

export default SummaryStatistics;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/ProfitVsPriceChart.jsx
```jsx
import React, { useMemo, useContext, useState, useCallback } from 'react';
import { ScatterChart, Scatter, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';
import { formatCompactNumber, formatCurrency } from '@/lib/utils';
import { DashboardContext } from '@/context/DashboardContext';

const CHUNK_SIZE = 100;

const ProfitVsPriceChart = () => {
  const { data, filters } = useContext(DashboardContext);
  const [displayedData, setDisplayedData] = useState([]);
  const [isLoading, setIsLoading] = useState(false);

  const filteredData = useMemo(() => {
    return data.filter(item =>
      (!filters.revenue || (item['TTM Revenue'] >= filters.revenue[0] && item['TTM Revenue'] <= filters.revenue[1])) &&
      (!filters.profit || (item['TTM Profit'] >= filters.profit[0] && item['TTM Profit'] <= filters.profit[1])) &&
      (!filters.price || (item['Asking Price'] >= filters.price[0] && item['Asking Price'] <= filters.price[1])) &&
      (!filters.businessType || filters.businessType === 'all' || item['Business Type'] === filters.businessType)
    );
  }, [data, filters]);

  const loadChunk = useCallback((startIndex) => {
    return new Promise((resolve) => {
      setTimeout(() => {
        const chunk = filteredData.slice(startIndex, startIndex + CHUNK_SIZE);
        resolve(chunk);
      }, 0);
    });
  }, [filteredData]);

  const loadData = useCallback(async () => {
    setIsLoading(true);
    setDisplayedData([]);
    
    for (let i = 0; i < filteredData.length; i += CHUNK_SIZE) {
      const chunk = await loadChunk(i);
      setDisplayedData(prev => [...prev, ...chunk]);
    }
    
    setIsLoading(false);
  }, [filteredData, loadChunk]);

  React.useEffect(() => {
    loadData();
  }, [loadData]);

  const calculateDomain = useCallback((data, key, buffer = 0.1) => {
    if (data.length === 0) return [0, 1];
    const values = data.map(item => Number(item[key]));
    const minValue = Math.min(...values);
    const maxValue = Math.max(...values);
    const range = maxValue - minValue;
    return [
      minValue < 0 ? minValue - Math.abs(range * buffer) : Math.max(0, minValue - range * buffer),
      maxValue + range * buffer
    ];
  }, []);

  const domains = useMemo(() => ({
    profit: calculateDomain(displayedData, 'TTM Profit'),
    price: calculateDomain(displayedData, 'Asking Price')
  }), [displayedData, calculateDomain]);

  if (isLoading) {
    return <div className="h-[300px] flex items-center justify-center">Loading chart data...</div>;
  }

  return (
    <ResponsiveContainer width="100%" height={300}>
      <ScatterChart margin={{ top: 20, right: 20, bottom: 20, left: 80 }}>
        <CartesianGrid />
        <XAxis
          type="number"
          dataKey="TTM Profit"
          name="Profit"
          unit="$"
          domain={domains.profit}
          tickFormatter={(value) => formatCompactNumber(value)}
        />
        <YAxis
          type="number"
          dataKey="Asking Price"
          name="Price"
          unit="$"
          domain={domains.price}
          tickFormatter={(value) => formatCompactNumber(value)}
        />
        <Tooltip
          formatter={(value, name) => [formatCurrency(value), name]}
          labelFormatter={() => ''}
        />
        <Scatter name="Profit vs Price" data={displayedData} fill="#82ca9d" />
      </ScatterChart>
    </ResponsiveContainer>
  );
};

export default React.memo(ProfitVsPriceChart);
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/Dashboard.jsx
```jsx
import React, { useContext, useState, useMemo } from 'react';
import { HelpCircle } from 'lucide-react';
import { DashboardContext } from '../context/DashboardContext';
import Filter from './Filter';
import StartupDetailsTable from './StartupDetailsTable';
import RevenueVsPriceChart from './RevenueVsPriceChart';
import ProfitVsPriceChart from './ProfitVsPriceChart';
import SummaryStatistics from './SummaryStatistics';
import { Card, CardHeader, CardTitle, CardContent } from './ui/card';
import { formatRatio } from "@/lib/utils";

const Dashboard = ({ isLoading }) => {
  const { data, hasUploadedData, isLoadingData, selectedFileIds } = useContext(DashboardContext);

  const [sortConfig, setSortConfig] = useState({ key: null, direction: 'ascending' });

  const hasSelectedData = selectedFileIds.length > 0;

  const averageMetrics = useMemo(() => {
    if (!hasUploadedData || data.length === 0) {
      return {
        avgRevenue: 0,
        avgProfit: 0,
        avgPrice: 0,
        avgPriceToRevenue: 'N/A',
        avgPriceToProfit: 'N/A',
      };
    }

    const sum = data.reduce((acc, item) => {
      acc.revenue += Number(item['TTM Revenue']) || 0;
      acc.profit += Number(item['TTM Profit']) || 0;
      acc.price += Number(item['Asking Price']) || 0;
      return acc;
    }, { revenue: 0, profit: 0, price: 0 });

    const count = data.length;
    const avgRevenue = sum.revenue / count;
    const avgProfit = sum.profit / count;
    const avgPrice = sum.price / count;

    const avgPriceToRevenue = avgRevenue !== 0 ? avgPrice / avgRevenue : 0;
    const avgPriceToProfit = avgProfit !== 0 ? avgPrice / avgProfit : 0;

    return {
      avgRevenue,
      avgProfit,
      avgPrice,
      avgPriceToRevenue: formatRatio(avgPriceToRevenue),
      avgPriceToProfit: formatRatio(avgPriceToProfit),
    };
  }, [data, hasUploadedData]);

  if (!hasSelectedData) {
    return (
      <div className="p-4 space-y-4">
        <h1 className="text-2xl font-bold mb-4">Dashboard 2.0</h1>
        <div className="flex items-center justify-center h-64">
          <p className="text-xl font-semibold">No files selected.</p>
        </div>
      </div>
    );
  }

  if (isLoadingData) {
    return (
      <div className="p-4 space-y-4">
        <h1 className="text-2xl font-bold mb-4">Dashboard 2.0</h1>
        <div className="flex items-center justify-center h-64">
          <svg className="animate-spin h-8 w-8 text-gray-500" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10"
              fill="none" stroke="currentColor" strokeWidth="4"></circle>
            <path className="opacity-75"
              fill="currentColor"
              d="M4 12a8 8 0 018-8v8H4z"></path>
          </svg>
        </div>
      </div>
    );
  }

  return (
    <div className="p-4 space-y-4">
      <h1 className="text-2xl font-bold mb-4">Dashboard 2.0</h1>
      <Filter />
      <SummaryStatistics
        averageMetrics={averageMetrics}
        hasUploadedData={hasUploadedData}
      />

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center">
              Revenue vs Price
              <div className="relative inline-block ml-2">
                <HelpCircle className="w-4 h-4 text-gray-400 cursor-help" />
              </div>
            </CardTitle>
          </CardHeader>
          <CardContent>
            {data.length === 0 ? (
              <div className="flex flex-col items-center justify-center h-64">
                <h3 className="text-xl font-semibold mb-2">No Data to Display</h3>
                <p className="text-gray-600 mb-4">Select files to see the Revenue vs Price chart.</p>
              </div>
            ) : (
              <RevenueVsPriceChart />
            )}
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="flex items-center">
              Profit vs Price
              <div className="relative inline-block ml-2">
                <HelpCircle className="w-4 h-4 text-gray-400 cursor-help" />
              </div>
            </CardTitle>
          </CardHeader>
          <CardContent>
            {data.length === 0 ? (
              <div className="flex flex-col items-center justify-center h-64">
                <h3 className="text-xl font-semibold mb-2">No Data to Display</h3>
                <p className="text-gray-600 mb-4">Select files to see the Profit vs Price chart.</p>
              </div>
            ) : (
              <ProfitVsPriceChart />
            )}
          </CardContent>
        </Card>
      </div>

      <Card>
        <CardHeader>
          <CardTitle className="flex items-center">
            Startup Details
            <div className="relative inline-block ml-2">
              <HelpCircle className="w-4 h-4 text-gray-400 cursor-help" />
            </div>
          </CardTitle>
        </CardHeader>
        <CardContent>
          {data.length === 0 ? (
            <div className="flex flex-col items-center justify-center h-64">
              <h3 className="text-xl font-semibold mb-2">No Startup Data Available</h3>
              <p className="text-gray-600 mb-4">Select files to see detailed startup information.</p>
            </div>
          ) : (
            <StartupDetailsTable
              onSort={(key) => setSortConfig({
                key,
                direction: sortConfig.direction === 'ascending' ? 'descending' : 'ascending'
              })}
              sortConfig={sortConfig}
            />
          )}
        </CardContent>
      </Card>
    </div>
  );
};

export default Dashboard;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/RangeFilter.jsx
```jsx
import React, { useState, useEffect } from 'react';
import * as SliderPrimitive from "@radix-ui/react-slider";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { formatCurrency } from '@/lib/utils';

const RangeFilter = ({ label, min, max, value, onChange, presets }) => {
  const [error, setError] = useState('');
  const [selectedPreset, setSelectedPreset] = useState(null);

  // Determine if this filter represents a currency field
  const isCurrencyField = label.toLowerCase().includes('revenue') ||
    label.toLowerCase().includes('profit') ||
    label.toLowerCase().includes('price');

  // Ensure that min, max, and value are valid before rendering
  if (min === undefined || max === undefined || !Array.isArray(value) || value.length !== 2) {
    console.error('Invalid props provided to RangeFilter:', { min, max, value });
    return null;
  }

  const handleInputChange = (index) => (e) => {
    const inputValue = e.target.value.trim() === '' ? '' : Number(e.target.value);
    const updatedValue = [...value];
    updatedValue[index] = inputValue;
    validateAndUpdate(updatedValue);
    setSelectedPreset(null);
  };

  const validateAndUpdate = (newValue) => {
    const [newMin, newMax] = newValue;
    if (typeof newMin !== 'number' || typeof newMax !== 'number' || isNaN(newMin) || isNaN(newMax)) {
      setError('Please enter valid numeric values');
      return;
    }

    if (newMin > newMax) {
      setError('Min value cannot be greater than max value');
    } else if (newMin < min || newMax > max) {
      setError(`Values must be between ${formatCurrency(min)} and ${formatCurrency(max)}`);
    } else {
      setError('');
      onChange(newValue);
    }
  };

  const handlePresetClick = (presetMin, presetMax, index) => {
    if (selectedPreset === index) {
      // If the preset is already selected, reset to the full range
      validateAndUpdate([min, max]);
      setSelectedPreset(null);
    } else {
      validateAndUpdate([presetMin, presetMax]);
      setSelectedPreset(index);
    }
  };

  const normalizeValue = (val) => {
    return ((val - min) / (max - min)) * 100;
  };

  const handleSliderChange = (newValue) => {
    const denormalizedValue = newValue.map((normalizedValue) => {
      return (normalizedValue / 100) * (max - min) + min;
    });
    validateAndUpdate(denormalizedValue);
    setSelectedPreset(null);
  };

  useEffect(() => {
    // Check if current value matches any preset
    const matchingPresetIndex = presets.findIndex(
      preset => preset.min === value[0] && preset.max === value[1]
    );
    setSelectedPreset(matchingPresetIndex !== -1 ? matchingPresetIndex : null);
  }, [value, presets]);

  // A helper component for the currency input fields
  const CurrencyInput = ({ val, onChangeHandler, ariaLabel }) => (
    <div className="flex items-center space-x-1">
      {isCurrencyField && <span className="text-gray-700">$</span>}
      <Input
        type="number"
        value={val}
        onChange={onChangeHandler}
        className="w-24"
        aria-label={ariaLabel}
      />
    </div>
  );

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <span className="text-sm font-medium text-gray-700">{label}</span>
        <span className="text-sm text-gray-500">
          {formatCurrency(value[0])} - {formatCurrency(value[1])}
        </span>
      </div>
      <SliderPrimitive.Root
        min={0}
        max={100}
        step={0.1}
        value={[normalizeValue(value[0]), normalizeValue(value[1])]}
        onValueChange={handleSliderChange}
        className="relative flex items-center w-full h-5 touch-none"
        aria-label={`${label} range`}
      >
        <SliderPrimitive.Track className="relative w-full h-2 grow rounded-full bg-gray-200">
          <SliderPrimitive.Range className="absolute h-full rounded-full bg-blue-500" />
        </SliderPrimitive.Track>
        <SliderPrimitive.Thumb
          className="block w-5 h-5 rounded-full bg-white border-2 border-blue-500 focus:outline-none focus-visible:ring focus-visible:ring-blue-300"
          aria-label={`${label} minimum value`}
        />
        <SliderPrimitive.Thumb
          className="block w-5 h-5 rounded-full bg-white border-2 border-blue-500 focus:outline-none focus-visible:ring focus-visible:ring-blue-300"
          aria-label={`${label} maximum value`}
        />
      </SliderPrimitive.Root>
      <div className="flex items-center space-x-4">
        <CurrencyInput
          val={value[0]}
          onChangeHandler={handleInputChange(0)}
          ariaLabel={`Minimum ${label}`}
        />
        <span className="text-gray-500">to</span>
        <CurrencyInput
          val={value[1]}
          onChangeHandler={handleInputChange(1)}
          ariaLabel={`Maximum ${label}`}
        />
      </div>
      {error && <p className="text-red-500 text-sm" role="alert">{error}</p>}
      <div className="flex flex-wrap gap-2">
        {presets.map((preset, index) => (
          <Button
            key={index}
            size="sm"
            onClick={() => handlePresetClick(preset.min, preset.max, index)}
            className={`transition-colors ${selectedPreset === index
                ? "bg-blue-500 text-white hover:bg-blue-600"
                : "bg-white text-gray-700 border border-gray-300 hover:bg-gray-100"
              }`}
          >
            {preset.label}
          </Button>
        ))}
      </div>
    </div>
  );
};

export default RangeFilter;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/TableHeader.jsx
```jsx
import React from 'react';
import { Info, ArrowUpDown } from 'lucide-react';
import { Tooltip } from "@/components/ui/tooltip";

const TableHeader = ({ sortConfig, onSort }) => {
  const HeaderCell = ({ label, sortKey, tooltip }) => (
    <div 
      className={`flex-1 px-4 py-2 font-medium cursor-pointer transition-colors hover:bg-gray-100 ${
        sortConfig.key === sortKey ? 'bg-blue-50' : ''
      }`}
      onClick={() => onSort(sortKey)}
    >
      <div className="flex items-center justify-between">
        <span>{label}</span>
        <div className="flex items-center">
          {tooltip && (
            <Tooltip content={tooltip}>
              <Info className="h-4 w-4 text-gray-400 mr-1" />
            </Tooltip>
          )}
          <ArrowUpDown className={`h-4 w-4 transition-transform ${
            sortConfig.key === sortKey 
              ? sortConfig.direction === 'ascending' 
                ? 'text-blue-500 rotate-180' 
                : 'text-blue-500'
              : 'text-gray-300'
          }`} />
        </div>
      </div>
    </div>
  );

  return (
    <div className="flex border-b bg-white sticky top-0 z-10">
      <HeaderCell label="Type" sortKey="Business Type" tooltip="Type of business" />
      <HeaderCell label="TTM Revenue" sortKey="TTM Revenue" tooltip="Trailing Twelve Months Revenue" />
      <HeaderCell label="TTM Profit" sortKey="TTM Profit" tooltip="Trailing Twelve Months Profit" />
      <HeaderCell label="Asking Price" sortKey="Asking Price" tooltip="Requested selling price" />
      <HeaderCell label="Price to Revenue" sortKey="price to revenue" tooltip="Asking Price / TTM Revenue" />
      <HeaderCell label="Price-to-Profit" sortKey="price-to-profit" tooltip="Asking Price / TTM Profit" />
      <div className="flex-1 px-4 py-2 font-medium">View</div>
      <div className="flex-1 px-4 py-2 font-medium">Actions</div>
    </div>
  );
};

export default React.memo(TableHeader);
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/Pagination.jsx
```jsx
import React from 'react';
import { Button } from "@/components/ui/button";
import { ChevronLeft, ChevronRight } from 'lucide-react';

const Pagination = ({ 
  currentPage, 
  totalPages, 
  pageSize, 
  totalRecords,
  onPageChange, 
  onPageSizeChange 
}) => {
  const pageSizes = [25, 50, 100];
  
  const getPageNumbers = () => {
    const delta = 2;
    const range = [];
    const rangeWithDots = [];
    let l;

    for (let i = 1; i <= totalPages; i++) {
      if (i === 1 || i === totalPages || (i >= currentPage - delta && i <= currentPage + delta)) {
        range.push(i);
      }
    }

    range.forEach(i => {
      if (l) {
        if (i - l === 2) {
          rangeWithDots.push(l + 1);
        } else if (i - l !== 1) {
          rangeWithDots.push('...');
        }
      }
      rangeWithDots.push(i);
      l = i;
    });

    return rangeWithDots;
  };

  return (
    <div className="flex items-center justify-between px-2 py-3 space-x-4">
      <div className="flex items-center space-x-2">
        <span className="text-sm text-gray-700">Show</span>
        <select
          value={pageSize}
          onChange={(e) => onPageSizeChange(Number(e.target.value))}
          className="border rounded p-1 text-sm"
        >
          {pageSizes.map(size => (
            <option key={size} value={size}>{size}</option>
          ))}
        </select>
        <span className="text-sm text-gray-700">entries</span>
      </div>

      <div className="flex items-center space-x-1">
        <Button
          variant="outline"
          size="sm"
          onClick={() => onPageChange(currentPage - 1)}
          disabled={currentPage === 1}
        >
          <ChevronLeft className="h-4 w-4" />
        </Button>

        {getPageNumbers().map((page, index) => (
          <React.Fragment key={index}>
            {page === '...' ? (
              <span className="px-2">...</span>
            ) : (
              <Button
                variant={currentPage === page ? 'default' : 'outline'}
                size="sm"
                onClick={() => onPageChange(page)}
              >
                {page}
              </Button>
            )}
          </React.Fragment>
        ))}

        <Button
          variant="outline"
          size="sm"
          onClick={() => onPageChange(currentPage + 1)}
          disabled={currentPage === totalPages}
        >
          <ChevronRight className="h-4 w-4" />
        </Button>
      </div>

      <div className="text-sm text-gray-700">
        Showing {Math.min((currentPage - 1) * pageSize + 1, totalRecords)} to{' '}
        {Math.min(currentPage * pageSize, totalRecords)} of {totalRecords} entries
      </div>
    </div>
  );
};

export default React.memo(Pagination);
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/Sidebar.jsx
```jsx
import React from 'react';
import { Link, useLocation } from 'react-router-dom';
import { Home, FileText, Upload } from 'lucide-react';
import { motion } from 'framer-motion';
import { Button } from "@/components/ui/button";

const Sidebar = () => {
  const location = useLocation();

  const isActive = (path) => {
    return location.pathname === path ? 'bg-gray-200 text-gray-900' : 'text-gray-600 hover:bg-gray-100 hover:text-gray-900';
  };

  return (
    <div className="flex flex-col w-64 bg-white border-r border-gray-200 h-screen">
      <div className="flex items-center justify-center h-16 border-b border-gray-200">
        <span className="text-gray-900 font-bold text-lg">Micro Startup Dashboard</span>
      </div>
      <nav className="flex-1">
        <ul className="space-y-2 py-4">
          <li>
            <Link to="/" className={`flex items-center px-4 py-2 text-sm font-medium ${isActive('/')}`}>
              <Home className="mr-3 h-6 w-6" />
              Dashboard
            </Link>
          </li>
          <li>
            <Link to="/file-management" className={`flex items-center px-4 py-2 text-sm font-medium ${isActive('/file-management')}`}>
              <FileText className="mr-3 h-6 w-6" />
              File Management
            </Link>
          </li>
        </ul>
      </nav>
      <div className="p-4 space-y-2">
        <h3 className="text-sm font-semibold text-gray-600 mb-2">Quick Actions</h3>
        <motion.div whileHover={{ scale: 1.05 }} whileTap={{ scale: 0.95 }}>
          <Link to="/file-management">
            <Button
              className="w-full flex items-center justify-center"
            >
              <Upload className="mr-2 h-4 w-4" />
              Upload File
            </Button>
          </Link>
        </motion.div>
      </div>
    </div>
  );
};

export default Sidebar;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/LazyChart.jsx
```jsx
import React, { Suspense } from 'react';
import { Skeleton } from "@/components/ui/skeleton";

const LazyChart = ({ Chart, data, height = 300 }) => {
  return (
    <Suspense fallback={<Skeleton className={`w-full h-${height}`} />}>
      <Chart data={data} />
    </Suspense>
  );
};

export default LazyChart;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/FileManagementContainer.jsx
```jsx
// FileManagementContainer.jsx
import React, { useContext, useCallback } from 'react';
import MultiFileUpload from './MultiFileUpload';
import FileList from './FileList';
import { DashboardContext } from '../context/DashboardContext';

/**
 * Updated to handle toggling multiple file selections.
 */

const FileManagementContainer = () => {
    const { files, setFiles, selectedFileIds, setSelectedFileIds } = useContext(DashboardContext);

    const handleFilesUploaded = useCallback((uploadedFiles) => {
        setFiles(prev => [...prev, ...uploadedFiles]);
        // No automatic selection here; user will select files manually.
    }, [setFiles]);

    const handleToggleFileSelection = (fileId) => {
        setSelectedFileIds(prev => {
            if (prev.includes(fileId)) {
                return prev.filter(id => id !== fileId);
            } else {
                return [...prev, fileId];
            }
        });
    };

    const handleDeleteFile = (id) => {
        setFiles(prev => prev.filter(f => f.id !== id));
        setSelectedFileIds(prev => prev.filter(fid => fid !== id));
    };

    return (
        <div className="flex flex-col md:flex-row p-4">
            <FileList
                files={files}
                selectedFileIds={selectedFileIds}
                onToggleFileSelection={handleToggleFileSelection}
                onDeleteFile={handleDeleteFile}
            />
            <div className="w-full md:w-3/4 p-4">
                <MultiFileUpload onFilesUploaded={handleFilesUploaded} />
            </div>
        </div>
    );
};

export default FileManagementContainer;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/StartupDetailsTable.jsx
```jsx
import React, { useState, useEffect, useContext, useMemo, useCallback } from 'react';
import { FixedSizeList as List } from 'react-window';
import InfiniteLoader from 'react-window-infinite-loader';
import AutoSizer from 'react-virtualized/dist/commonjs/AutoSizer';
import { DashboardContext } from '@/context/DashboardContext';
import { calculateFinancialRatioAsNumber } from "@/lib/utils";
import TableHeader from './TableHeader';
import VirtualRow from './VirtualRow';
import Pagination from './Pagination';

const ROW_HEIGHT = 48;

const StartupDetailsTable = ({ onSort, sortConfig }) => {
  const { data, filters, removeListingFromData } = useContext(DashboardContext);
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize, setPageSize] = useState(25);
  const [isNextPageLoading, setIsNextPageLoading] = useState(false);
  
  const filteredData = useMemo(() => {
    return data.filter(item =>
      (!filters.revenue || (item['TTM Revenue'] >= filters.revenue[0] && item['TTM Revenue'] <= filters.revenue[1])) &&
      (!filters.profit || (item['TTM Profit'] >= filters.profit[0] && item['TTM Profit'] <= filters.profit[1])) &&
      (!filters.price || (item['Asking Price'] >= filters.price[0] && item['Asking Price'] <= filters.price[1])) &&
      (!filters.businessType || filters.businessType === 'all' || item['Business Type'] === filters.businessType)
    );
  }, [data, filters]);

  const sortedData = useMemo(() => {
    let sortableItems = [...filteredData];
    if (sortConfig.key !== null) {
      sortableItems.sort((a, b) => {
        let aValue, bValue;

        if (sortConfig.key === 'price to revenue') {
          aValue = calculateFinancialRatioAsNumber(a['Asking Price'], a['TTM Revenue']);
          bValue = calculateFinancialRatioAsNumber(b['Asking Price'], b['TTM Revenue']);
        } else if (sortConfig.key === 'price-to-profit') {
          aValue = calculateFinancialRatioAsNumber(a['Asking Price'], a['TTM Profit']);
          bValue = calculateFinancialRatioAsNumber(b['Asking Price'], b['TTM Profit']);
        } else {
          aValue = typeof a[sortConfig.key] === 'string' && !isNaN(a[sortConfig.key].replace(/[^0-9.-]+/g, ""))
            ? parseFloat(a[sortConfig.key].replace(/[^0-9.-]+/g, ""))
            : a[sortConfig.key];
          bValue = typeof b[sortConfig.key] === 'string' && !isNaN(b[sortConfig.key].replace(/[^0-9.-]+/g, ""))
            ? parseFloat(b[sortConfig.key].replace(/[^0-9.-]+/g, ""))
            : b[sortConfig.key];
        }

        if (aValue === null || aValue === 0) return sortConfig.direction === 'ascending' ? 1 : -1;
        if (bValue === null || bValue === 0) return sortConfig.direction === 'ascending' ? -1 : 1;

        return sortConfig.direction === 'ascending' ? aValue - bValue : bValue - aValue;
      });
    }
    return sortableItems;
  }, [filteredData, sortConfig]);

  // Calculate the current page's data
  const currentPageData = useMemo(() => {
    const startIndex = (currentPage - 1) * pageSize;
    const endIndex = startIndex + pageSize;
    return sortedData.slice(startIndex, endIndex);
  }, [sortedData, currentPage, pageSize]);

  const handlePageChange = useCallback((page) => {
    setCurrentPage(page);
  }, []);

  const handlePageSizeChange = useCallback((newSize) => {
    setPageSize(newSize);
    setCurrentPage(1); // Reset to first page when changing page size
  }, []);

  const handleRemove = useCallback((id) => {
    setTimeout(() => {
      removeListingFromData(id);
    }, 300);
  }, [removeListingFromData]);

  // Reset to first page when filtered data changes
  useEffect(() => {
    setCurrentPage(1);
  }, [filteredData.length]);

  const loadMoreItems = useCallback(async (startIndex, stopIndex) => {
    setIsNextPageLoading(true);
    await new Promise(resolve => setTimeout(resolve, 100));
    setIsNextPageLoading(false);
  }, []);

  const isItemLoaded = useCallback(index => {
    return index < currentPageData.length;
  }, [currentPageData.length]);

  return (
    <div className="h-[600px] relative">
      <TableHeader sortConfig={sortConfig} onSort={onSort} />

      <div className="h-[500px]">
        <AutoSizer>
          {({ height, width }) => (
            <InfiniteLoader
              isItemLoaded={isItemLoaded}
              itemCount={currentPageData.length}
              loadMoreItems={loadMoreItems}
              minimumBatchSize={pageSize}
            >
              {({ onItemsRendered, ref }) => (
                <List
                  ref={ref}
                  height={height}
                  itemCount={currentPageData.length}
                  itemSize={ROW_HEIGHT}
                  width={width}
                  onItemsRendered={onItemsRendered}
                >
                  {({ index, style }) => (
                    <VirtualRow
                      index={index}
                      style={style}
                      data={currentPageData}
                      onRemove={handleRemove}
                    />
                  )}
                </List>
              )}
            </InfiniteLoader>
          )}
        </AutoSizer>
      </div>

      <Pagination
        currentPage={currentPage}
        totalPages={Math.ceil(sortedData.length / pageSize)}
        pageSize={pageSize}
        totalRecords={sortedData.length}
        onPageChange={handlePageChange}
        onPageSizeChange={handlePageSizeChange}
      />
    </div>
  );
};

export default React.memo(StartupDetailsTable);
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/FileManagement.jsx
```jsx
import React from 'react';
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import FileManagementContainer from './FileManagementContainer';

const FileManagement = () => {
  return (
    <div className="p-4 space-y-4">
      <h1 className="text-2xl font-bold mb-4">File Management</h1>
      <Card>
        <CardHeader>
          <CardTitle>Files and Assets</CardTitle>
        </CardHeader>
        <CardContent>
          <FileManagementContainer />
        </CardContent>
      </Card>
    </div>
  );
};

export default FileManagement;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/RevenueVsPriceChart.jsx
```jsx
import React, { useMemo, useContext, useState, useCallback } from 'react';
import { ScatterChart, Scatter, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';
import { formatCompactNumber, formatCurrency } from '@/lib/utils';
import { DashboardContext } from '@/context/DashboardContext';

const CHUNK_SIZE = 100;

const RevenueVsPriceChart = () => {
  const { data, filters } = useContext(DashboardContext);
  const [displayedData, setDisplayedData] = useState([]);
  const [isLoading, setIsLoading] = useState(false);

  const filteredData = useMemo(() => {
    return data.filter(item =>
      (!filters.revenue || (item['TTM Revenue'] >= filters.revenue[0] && item['TTM Revenue'] <= filters.revenue[1])) &&
      (!filters.profit || (item['TTM Profit'] >= filters.profit[0] && item['TTM Profit'] <= filters.profit[1])) &&
      (!filters.price || (item['Asking Price'] >= filters.price[0] && item['Asking Price'] <= filters.price[1])) &&
      (!filters.businessType || filters.businessType === 'all' || item['Business Type'] === filters.businessType)
    );
  }, [data, filters]);

  const loadChunk = useCallback((startIndex) => {
    return new Promise((resolve) => {
      setTimeout(() => {
        const chunk = filteredData.slice(startIndex, startIndex + CHUNK_SIZE);
        resolve(chunk);
      }, 0);
    });
  }, [filteredData]);

  const loadData = useCallback(async () => {
    setIsLoading(true);
    setDisplayedData([]);
    
    for (let i = 0; i < filteredData.length; i += CHUNK_SIZE) {
      const chunk = await loadChunk(i);
      setDisplayedData(prev => [...prev, ...chunk]);
    }
    
    setIsLoading(false);
  }, [filteredData, loadChunk]);

  React.useEffect(() => {
    loadData();
  }, [loadData]);

  const calculateDomain = useCallback((data, key, buffer = 0.1, allowNegative = false) => {
    if (data.length === 0) return [0, 1];
    const minValue = allowNegative ? Math.min(...data.map(item => item[key])) : Math.max(0, Math.min(...data.map(item => item[key])));
    const maxValue = Math.max(...data.map(item => item[key]));
    const range = maxValue - minValue;
    return [
      minValue - (allowNegative ? range * buffer : 0),
      maxValue + range * buffer
    ];
  }, []);

  const domains = useMemo(() => ({
    revenue: calculateDomain(displayedData, 'TTM Revenue', 0.1, false),
    price: calculateDomain(displayedData, 'Asking Price', 0.1, true)
  }), [displayedData, calculateDomain]);

  if (isLoading) {
    return <div className="h-[300px] flex items-center justify-center">Loading chart data...</div>;
  }

  return (
    <ResponsiveContainer width="100%" height={300}>
      <ScatterChart margin={{ top: 20, right: 20, bottom: 20, left: 80 }}>
        <CartesianGrid />
        <XAxis
          type="number"
          dataKey="TTM Revenue"
          name="Revenue"
          unit="$"
          domain={domains.revenue}
          tickFormatter={(value) => formatCompactNumber(value)}
        />
        <YAxis
          type="number"
          dataKey="Asking Price"
          name="Price"
          unit="$"
          domain={domains.price}
          tickFormatter={(value) => formatCompactNumber(value)}
        />
        <Tooltip
          formatter={(value, name) => [formatCurrency(value), name]}
          labelFormatter={() => ''}
        />
        <Scatter name="Revenue vs Price" data={displayedData} fill="#8884d8" />
      </ScatterChart>
    </ResponsiveContainer>
  );
};

export default React.memo(RevenueVsPriceChart);
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/VirtualTable.jsx
```jsx
import React, { useCallback } from 'react';
import { FixedSizeList as List } from 'react-window';
import AutoSizer from 'react-virtualized/dist/commonjs/AutoSizer';
import { TableRow, TableCell } from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Trash2, ExternalLink } from 'lucide-react';
import { formatCurrency, calculateFinancialRatio } from "@/lib/utils";

const ROW_HEIGHT = 48;

const VirtualTable = ({ data, onRemove }) => {
  const Row = useCallback(({ index, style }) => {
    const item = data[index];
    return (
      <TableRow 
        style={style}
        className={`${index % 2 === 0 ? 'bg-gray-50' : ''} absolute w-full`}
      >
        <TableCell>{item['Business Type']}</TableCell>
        <TableCell className="text-right">{formatCurrency(item['TTM Revenue'])}</TableCell>
        <TableCell className="text-right">{formatCurrency(item['TTM Profit'])}</TableCell>
        <TableCell className="text-right">{formatCurrency(item['Asking Price'])}</TableCell>
        <TableCell className="text-right">{calculateFinancialRatio(item['Asking Price'], item['TTM Revenue'])}</TableCell>
        <TableCell className="text-right">{calculateFinancialRatio(item['Asking Price'], item['TTM Profit'])}</TableCell>
        <TableCell>
          <a href={item['marketplace-card href']} target="_blank" rel="noopener noreferrer">
            <ExternalLink className="h-4 w-4" />
          </a>
        </TableCell>
        <TableCell>
          <Button variant="ghost" size="sm" onClick={() => onRemove(item.id)}>
            <Trash2 className="h-4 w-4" />
          </Button>
        </TableCell>
      </TableRow>
    );
  }, [data, onRemove]);

  return (
    <div style={{ height: '400px' }}>
      <AutoSizer>
        {({ height, width }) => (
          <List
            height={height}
            itemCount={data.length}
            itemSize={ROW_HEIGHT}
            width={width}
          >
            {Row}
          </List>
        )}
      </AutoSizer>
    </div>
  );
};

export default React.memo(VirtualTable);
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/hooks/useDebounce.js
```js
import { useCallback } from 'react';

export const useDebounce = (callback, delay) => {
  let timeoutId;

  return useCallback((...args) => {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }

    timeoutId = setTimeout(() => {
      callback(...args);
    }, delay);
  }, [callback, delay]);
};
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/hooks/useChartData.js
```js
import { useState, useEffect, useCallback } from 'react';

const CHUNK_SIZE = 100;

export const useChartData = (data) => {
  const [chartData, setChartData] = useState([]);
  const [isLoading, setIsLoading] = useState(true);

  const loadChunk = useCallback((startIndex) => {
    return new Promise((resolve) => {
      setTimeout(() => {
        const chunk = data.slice(startIndex, startIndex + CHUNK_SIZE);
        resolve(chunk);
      }, 0);
    });
  }, [data]);

  const loadData = useCallback(async () => {
    setIsLoading(true);
    const chunks = [];
    for (let i = 0; i < data.length; i += CHUNK_SIZE) {
      const chunk = await loadChunk(i);
      chunks.push(...chunk);
      setChartData(prevData => [...prevData, ...chunk]);
    }
    setIsLoading(false);
  }, [data, loadChunk]);

  useEffect(() => {
    setChartData([]);
    loadData();
  }, [loadData]);

  return { chartData, isLoading };
};
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/hooks/useTableData.js
```js
import { useState, useMemo, useCallback } from 'react';

export const useTableData = (data, initialPageSize = 25) => {
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize, setPageSize] = useState(initialPageSize);
  const [sortConfig, setSortConfig] = useState({ key: null, direction: 'ascending' });

  const totalPages = Math.ceil(data.length / pageSize);
  const startIndex = (currentPage - 1) * pageSize;
  const endIndex = startIndex + pageSize;

  const sortedData = useMemo(() => {
    if (!sortConfig.key) return data;

    return [...data].sort((a, b) => {
      if (a[sortConfig.key] < b[sortConfig.key]) {
        return sortConfig.direction === 'ascending' ? -1 : 1;
      }
      if (a[sortConfig.key] > b[sortConfig.key]) {
        return sortConfig.direction === 'ascending' ? 1 : -1;
      }
      return 0;
    });
  }, [data, sortConfig]);

  const currentPageData = useMemo(() => {
    return sortedData.slice(startIndex, endIndex);
  }, [sortedData, startIndex, endIndex]);

  const handlePageChange = useCallback((page) => {
    setCurrentPage(page);
  }, []);

  const handlePageSizeChange = useCallback((newSize) => {
    setPageSize(newSize);
    setCurrentPage(1);
  }, []);

  const handleSort = useCallback((key) => {
    setSortConfig((prevConfig) => ({
      key,
      direction:
        prevConfig.key === key && prevConfig.direction === 'ascending'
          ? 'descending'
          : 'ascending',
    }));
  }, []);

  return {
    currentPageData,
    currentPage,
    pageSize,
    totalPages,
    totalRecords: data.length,
    sortConfig,
    handlePageChange,
    handlePageSizeChange,
    handleSort,
  };
};
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/App.jsx
```jsx
import React from 'react';
import { BrowserRouter as Router, Route, Routes } from 'react-router-dom';
import Dashboard from './components/Dashboard';
import FileManagement from './components/FileManagement';
import Sidebar from './components/Sidebar';
import ErrorBoundary from './components/ErrorBoundary';
import { DashboardProvider } from './context/DashboardContext';
import { TooltipProvider } from './components/ui/tooltip';
import './index.css';

const Layout = ({ children }) => (
  <div className="flex h-screen bg-white">
    <Sidebar />
    <main className="flex-1 overflow-x-hidden overflow-y-auto">
      {children}
    </main>
  </div>
);

export default function App() {
  return (
    <ErrorBoundary>
      <TooltipProvider>
        <Router>
          <DashboardProvider>
            <div className="App">
              <Layout>
                <Routes>
                  <Route path="/" element={<Dashboard />} />
                  <Route path="/file-management" element={<FileManagement />} />
                </Routes>
              </Layout>
            </div>
          </DashboardProvider>
        </Router>
      </TooltipProvider>
    </ErrorBoundary>
  );
}
```
</file_contents>


</existing_code>

Here is the new feature request:
<feature_request>
    <business_requirements>
        <non_technical_requirements>
            <user_story>
                <description>As an investor, I want to easily compare key metrics of multiple businesses side-by-side so that I can quickly identify the most attractive opportunities without navigating back and forth.</description>
                <acceptance_criteria>
                    <criterion>Given I am viewing a table of businesses, when I click "Compare" on a business row, then that business is added to a comparison panel at the top of the page.</criterion>
                    <criterion>Given that I have selected multiple businesses, when the comparison panel is visible, then the metrics (TTM Revenue, TTM Profit, Asking Price, Price-to-Revenue, Price-to-Profit) are displayed side-by-side.</criterion>
                    <criterion>Given multiple businesses in the comparison, the best metric values should be visually highlighted.</criterion>
                    <criterion>Given the comparison panel is visible, when I click a remove button on a particular business, that business is removed from the panel and the highlight recalculates.</criterion>
                </acceptance_criteria>
            </user_story>
            <business_rules>
                <rule>At least one business selection is required to display the comparison panel.</rule>
                <rule>Consider limiting the number of businesses to compare (e.g., max 4).</rule>
                <rule>Must support keyboard navigation and accessibility standards.</rule>
                <rule>Must maintain responsive design for desktop, tablet, and mobile screens.</rule>
            </business_rules>
        </non_technical_requirements>
    </business_requirements>

    <technical_requirements>
        <react_implementation>
            <component_structure>
                <component name="BusinessTable">
                    <description>Renders the list of businesses and their "Compare" buttons.</description>
                </component>
                <component name="ComparisonBar">
                    <description>Fixed/sticky component at the top that displays selected businesses side-by-side.</description>
                </component>
                <component name="ComparisonCard">
                    <description>A child component of ComparisonBar representing each selected business's data.</description>
                </component>
                <component name="HighlightMetrics">
                    <description>Utility/helper function (hook or standalone) to determine best metrics.</description>
                </component>
            </component_structure>
            
            <state_management>
                <approach>Use useState or useReducer in a top-level component to track selected business IDs and their data.</approach>
                <optimization>Consider using useMemo to compute standout metrics once the list of selected businesses changes.</optimization>
            </state_management>
            
            <required_hooks>
                <hook>useState for managing selected businesses.</hook>
                <hook>useMemo for calculating and memoizing best metric values.</hook>
                <hook>useEffect (if needed) for fetching updated business data.</hook>
                <hook>useCallback for handling selection and removal actions efficiently.</hook>
            </required_hooks>
            
            <props_interface>
                <component name="BusinessTable">
                    <prop>businesses: Business[]</prop>
                    <prop>onCompareSelect: (id: string) => void</prop>
                </component>
                <component name="ComparisonBar">
                    <prop>selectedBusinesses: Business[]</prop>
                    <prop>onRemove: (id: string) => void</prop>
                </component>
                <component name="ComparisonCard">
                    <prop>business: Business</prop>
                    <prop>isBestMetric: (metricName: string) => boolean</prop>
                    <prop>onRemove: () => void</prop>
                </component>
            </props_interface>
        </react_implementation>

        <tailwind_specifications>
            <layout_classes>
                <class name="comparison_bar">fixed top-0 w-full bg-white shadow-md flex overflow-x-auto</class>
                <class name="cards_in_bar">flex flex-col p-4 border-r border-gray-200</class>
            </layout_classes>
            <responsive_design>
                <class>overflow-x-auto for smaller screens</class>
                <breakpoints>Use sm:, md:, lg: breakpoints to adjust font-size and padding.</breakpoints>
            </responsive_design>
            <custom_styling>
                <style name="best_metric">font-bold text-green-600</style>
                <style name="standard_metrics">text-gray-700</style>
                <style name="compare_button">text-blue-600 hover:underline</style>
                <style name="remove_button">text-red-500 hover:text-red-700 focus:outline-none</style>
            </custom_styling>
        </tailwind_specifications>

        <api_requirements>
            <requirement>No new endpoints required if data is already available.</requirement>
            <requirement>Must have unique identifiers and numeric values for all required metrics.</requirement>
            <requirement>If data updates in real-time, handle re-rendering gracefully.</requirement>
        </api_requirements>

        <performance_requirements>
            <requirement>Minimize re-renders by memoizing computed standout metrics.</requirement>
            <requirement>Virtualize large tables if performance issues arise.</requirement>
        </performance_requirements>
    </technical_requirements>

    <validation>
        <test_scenarios>
            <scenario>
                <name>Scenario 1</name>
                <description>Add a single business using "Compare" and verify comparison bar appears with correct data.</description>
            </scenario>
            <scenario>
                <name>Scenario 2</name>
                <description>Add multiple businesses and verify side-by-side comparison with correct alignment.</description>
            </scenario>
            <scenario>
                <name>Scenario 3</name>
                <description>Remove a business from comparison and verify the metrics and highlighting update correctly.</description>
            </scenario>
            <scenario>
                <name>Scenario 4</name>
                <description>Verify that highlighting is assigned to the best metrics.</description>
            </scenario>
            <scenario>
                <name>Scenario 5</name>
                <description>Check keyboard navigation (Tab through "Compare" buttons and remove actions).</description>
            </scenario>
        </test_scenarios>

        <edge_cases>
            <case>
                <name>No Businesses Selected</name>
                <handling>Comparison bar should not appear.</handling>
            </case>
            <case>
                <name>Max Businesses Reached</name>
                <handling>Attempts to add another business could either replace the oldest selection or block addition.</handling>
            </case>
            <case>
                <name>Data Missing Metrics</name>
                <handling>Display a placeholder or a "N/A" indicator.</handling>
            </case>
            <case>
                <name>Large Numbers</name>
                <handling>Metrics formatting should handle large values gracefully.</handling>
            </case>
        </edge_cases>

        <performance_metrics>
            <metric>Interaction response should be under 200ms for visible UI updates.</metric>
            <metric>Rendering should remain smooth under typical data sizes.</metric>
        </performance_metrics>
    </validation>
</feature_specification></feature_request>


Before providing your response, analyze the request in your scratchpad:
1. Check compatibility with existing features
2. Identify potential component reuse opportunities
3. Consider state management needs
4. Plan the component hierarchy
5. Consider styling consistency with existing components

Write your analysis in <scratchpad> tags.

Then,provide your complete response in <answer> tags, structured as follows:

1. Component Structure
- Parent/child relationships
- Props interface
- State management approach

2. Styling Approach
- Tailwind class recommendations
- Custom style requirements (if any)
- Responsive design considerations

3. Implementation Details
- Step-by-step implementation guide
- Code snippets for key functionality
- Integration points with existing features

4. Testing Considerations
- Unit test requirements
- Integration test scenarios
- Edge cases to consider

Your response should be detailed enough for a React developer to implement the feature while
maintaining consistency with the existing codebase. Include specific Tailwind classes and React
patterns that align with modern best practices. 

Do not include theoretical alternatives or options - provide a output that should be entire new code files or if there are code updates to existing files then provide the entire code file with the updates. Make sure you are not being lazy in your response and use the maximum amount of output tokens.

Begin your analysis now.