You will help plan and design a new feature addition to an existing React/Tailwind codebase. You
will receive information about the existing features, the new feature request, and any technical
constraints. Your goal is to provide a detailed, structured response that outlines how to implement
this feature while maintaining consistency with the existing codebase.

First, review the existing code:
<existing_code>
<file_contents>
File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/context/DashboardContext.jsx
```jsx
import React, { createContext, useState, useCallback, useMemo } from 'react';

/**
 * DashboardContext provides global state for the dashboard and file management.
 * This includes:
 * - files: array of uploaded file objects { id, name, data, metadata }.
 * - selectedFileId: the ID of the currently selected file.
 * - data: the data array of the selected file.
 * - filters, filterRanges: used for filtering dashboard data.
 * - updateFilterRanges: updates filterRanges based on current data.
 * - setFiles, setSelectedFileId: update the files and selected file.
 * - hasUploadedData: boolean indicating if there's any uploaded data.
 * - businessTypes: derived from the current data set if needed.
 */

export const DashboardContext = createContext();

export const DashboardProvider = ({ children }) => {
  const [files, setFiles] = useState([]);
  const [selectedFileId, setSelectedFileId] = useState(null);

  // Filters and ranges
  const [filters, setFilters] = useState({
    revenue: [0, 0],
    profit: [0, 0],
    price: [0, 0],
    businessType: 'all',
  });

  const [filterRanges, setFilterRanges] = useState({
    revenue: [0, 0],
    profit: [0, 0],
    price: [0, 0],
  });

  const updateFilterRanges = useCallback((data) => {
    // When data changes or when files are updated, determine min/max ranges:
    // Only update if we have data
    if (!data || data.length === 0) return;

    const getNumeric = (item, key) => Number(item[key]) || 0;

    const minRevenue = Math.min(...data.map(d => getNumeric(d, 'TTM Revenue')));
    const maxRevenue = Math.max(...data.map(d => getNumeric(d, 'TTM Revenue')));
    const minProfit = Math.min(...data.map(d => getNumeric(d, 'TTM Profit')));
    const maxProfit = Math.max(...data.map(d => getNumeric(d, 'TTM Profit')));
    const minPrice = Math.min(...data.map(d => getNumeric(d, 'Asking Price')));
    const maxPrice = Math.max(...data.map(d => getNumeric(d, 'Asking Price')));

    setFilterRanges({
      revenue: [minRevenue, maxRevenue],
      profit: [minProfit, maxProfit],
      price: [minPrice, maxPrice]
    });

    // Reset filters to full range if needed (if initial upload)
    setFilters(prevFilters => {
      const updated = { ...prevFilters };
      if (prevFilters.revenue[0] === 0 && prevFilters.revenue[1] === 0) {
        updated.revenue = [minRevenue, maxRevenue];
      }
      if (prevFilters.profit[0] === 0 && prevFilters.profit[1] === 0) {
        updated.profit = [minProfit, maxProfit];
      }
      if (prevFilters.price[0] === 0 && prevFilters.price[1] === 0) {
        updated.price = [minPrice, maxPrice];
      }
      return updated;
    });
  }, []);

  // Derive currently selected file's data
  const selectedFile = useMemo(() => {
    return files.find(f => f.id === selectedFileId) || null;
  }, [files, selectedFileId]);

  const data = selectedFile && selectedFile.data ? selectedFile.data : [];
  const hasUploadedData = files.length > 0;

  // Derive business types if needed
  const businessTypes = useMemo(() => {
    if (!hasUploadedData) return ['all'];
    const types = new Set();
    data.forEach(item => {
      if (item['Business Type']) {
        types.add(item['Business Type']);
      }
    });
    return ['all', ...Array.from(types)];
  }, [data, hasUploadedData]);

  return (
    <DashboardContext.Provider
      value={{
        files,
        setFiles,
        selectedFileId,
        setSelectedFileId,
        data,
        filters,
        setFilters,
        filterRanges,
        updateFilterRanges,
        hasUploadedData,
        businessTypes
      }}
    >
      {children}
    </DashboardContext.Provider>
  );
};
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/VirtualRow.jsx
```jsx
import React from 'react';
import { Trash2, ExternalLink } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { formatCurrency, calculateFinancialRatio } from "@/lib/utils";

const VirtualRow = React.memo(({ index, style, data, onRemove }) => {
  const item = data[index];
  if (!item) return null;

  return (
    <div style={style} className={`flex ${index % 2 === 0 ? 'bg-gray-50' : ''}`}>
      <div className="flex-1 px-4 py-2">{item['Business Type']}</div>
      <div className="flex-1 px-4 py-2 text-right">{formatCurrency(item['TTM Revenue'])}</div>
      <div className="flex-1 px-4 py-2 text-right">{formatCurrency(item['TTM Profit'])}</div>
      <div className="flex-1 px-4 py-2 text-right">{formatCurrency(item['Asking Price'])}</div>
      <div className="flex-1 px-4 py-2 text-right">
        {calculateFinancialRatio(item['Asking Price'], item['TTM Revenue'])}
      </div>
      <div className="flex-1 px-4 py-2 text-right">
        {calculateFinancialRatio(item['Asking Price'], item['TTM Profit'])}
      </div>
      <div className="flex-1 px-4 py-2">
        <a href={item['marketplace-card href']} target="_blank" rel="noopener noreferrer">
          <ExternalLink className="h-4 w-4" />
        </a>
      </div>
      <div className="flex-1 px-4 py-2">
        <Button variant="ghost" size="sm" onClick={() => onRemove(item.id)}>
          <Trash2 className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
});

VirtualRow.displayName = 'VirtualRow';

export default VirtualRow;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/MultiFileUpload.jsx
```jsx
// MultiFileUpload.jsx
import React, { useState, useRef } from 'react';
import Papa from 'papaparse';

const MultiFileUpload = ({ onFilesUploaded }) => {
    const [localFiles, setLocalFiles] = useState([]);
    const [error, setError] = useState(null);
    const [uploading, setUploading] = useState(false);
    const [progress, setProgress] = useState(0);
    const fileInputRef = useRef(null);

    const handleFileSelect = (e) => {
        const files = Array.from(e.target.files);
        setLocalFiles(files);
        setError(null);
    };

    const handleDrop = (e) => {
        e.preventDefault();
        const files = Array.from(e.dataTransfer.files);
        setLocalFiles(files);
        setError(null);
    };

    const handleDragOver = (e) => e.preventDefault();

    const handleUpload = async () => {
        if (localFiles.length === 0) return;
        setUploading(true);
        setError(null);
        try {
            const parsedFiles = [];
            for (let i = 0; i < localFiles.length; i++) {
                const file = localFiles[i];
                if (file.type !== 'text/csv' && file.name.slice(-4) !== '.csv') {
                    throw new Error(`Unsupported file type for ${file.name}. Only CSV allowed.`);
                }
                const data = await parseCSV(file);
                parsedFiles.push({
                    id: `${file.name}-${file.lastModified}`,
                    name: file.name,
                    data,
                    metadata: {
                        size: file.size,
                        lastModified: file.lastModified
                    }
                });
                setProgress(Math.round(((i + 1) / localFiles.length) * 100));
            }
            onFilesUploaded(parsedFiles);
            setLocalFiles([]);
        } catch (err) {
            console.error(err);
            setError(err.message);
        } finally {
            setUploading(false);
        }
    };

    const parseCSV = (file) => {
        return new Promise((resolve, reject) => {
            Papa.parse(file, {
                complete: results => {
                    if (results.errors.length > 0) {
                        reject(new Error(`Error parsing ${file.name}: ${results.errors[0].message}`));
                    } else {
                        resolve(results.data);
                    }
                },
                error: (err) => reject(err),
                header: true,
                skipEmptyLines: true
            });
        });
    };

    return (
        <div className="p-4">
            <div
                className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer"
                onDrop={handleDrop}
                onDragOver={handleDragOver}
                onClick={() => fileInputRef.current.click()}
            >
                <input
                    ref={fileInputRef}
                    type="file"
                    multiple
                    accept=".csv"
                    className="hidden"
                    onChange={handleFileSelect}
                />
                <p className="text-lg mb-2">Click to upload or drag and drop</p>
                <p className="text-sm text-gray-500">CSV files only, max size ~50MB</p>
            </div>
            {error && <p className="mt-4 text-red-500">{error}</p>}
            {localFiles.length > 0 && (
                <ul className="mt-4 list-disc pl-5 space-y-1 text-sm text-gray-700">
                    {localFiles.map((f, idx) => <li key={idx}>{f.name}</li>)}
                </ul>
            )}
            {uploading && (
                <div className="mt-4">
                    <div className="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
                        <div
                            className="bg-blue-600 h-2.5 rounded-full"
                            style={{ width: `${progress}%` }}
                        ></div>
                    </div>
                    <p className="text-center mt-2">{progress}% Uploaded</p>
                </div>
            )}
            <button
                className="mt-4 bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 disabled:bg-gray-400"
                onClick={handleUpload}
                disabled={localFiles.length === 0 || uploading}
            >
                {uploading ? 'Uploading...' : 'Upload Files'}
            </button>
        </div>
    );
};

export default MultiFileUpload;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/FileList.jsx
```jsx
// FileList.jsx
import React from 'react';
import { Trash2 } from 'lucide-react';

const FileList = ({ files, selectedFileId, onSelectFile, onDeleteFile }) => {
    return (
        <div className="w-full md:w-1/4 border-r border-gray-200 p-2 space-y-2">
            <h2 className="font-bold text-lg">Uploaded Files</h2>
            {files.length === 0 ? (
                <p className="text-gray-500 text-sm">No files uploaded yet.</p>
            ) : (
                <ul className="space-y-1">
                    {files.map(file => (
                        <li
                            key={file.id}
                            className={`flex justify-between items-center p-2 rounded cursor-pointer hover:bg-gray-100 ${file.id === selectedFileId ? 'bg-blue-100' : ''
                                }`}
                            onClick={() => onSelectFile(file.id)}
                        >
                            <span className="font-medium truncate">{file.name}</span>
                            <button
                                className="text-red-500 hover:text-red-700"
                                onClick={(e) => {
                                    e.stopPropagation();
                                    onDeleteFile(file.id);
                                }}
                            >
                                <Trash2 className="w-4 h-4" />
                            </button>
                        </li>
                    ))}
                </ul>
            )}
        </div>
    );
};

export default FileList;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/FileUpload.jsx
```jsx
import React, { useState } from 'react';
import { Button } from './ui/button';
import { Card } from './ui/card';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from './ui/table';
import Papa from 'papaparse';

const FileUpload = ({ onUpload }) => {
  const [files, setFiles] = useState([]);
  const [uploading, setUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [uploadedFiles, setUploadedFiles] = useState([]);
  const [error, setError] = useState(null);

  const handleFileChange = (event) => {
    setFiles(Array.from(event.target.files));
    setError(null);
  };

  const handleDrop = (event) => {
    event.preventDefault();
    setFiles(Array.from(event.dataTransfer.files));
    setError(null);
  };

  const handleDragOver = (event) => {
    event.preventDefault();
  };

  const processCSV = (file) => {
    return new Promise((resolve, reject) => {
      Papa.parse(file, {
        complete: (results) => {
          resolve(results.data);
        },
        error: (error) => {
          reject(error);
        },
        header: true,
        skipEmptyLines: true,
      });
    });
  };

  const handleUpload = async () => {
    setUploading(true);
    setUploadProgress(0);
    setError(null);

    try {
      const processedData = [];
      let lastFileMetadata = null;

      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        setUploadProgress(Math.round((i / files.length) * 100));

        if (file.type === 'text/csv') {
          const data = await processCSV(file);
          processedData.push(...data);

          lastFileMetadata = {
            name: file.name,
            type: file.type,
            size: file.size,
            lastModified: file.lastModified,
          };
        } else {
          throw new Error(`Unsupported file type: ${file.type}. Please upload CSV files only.`);
        }
      }

      const newUploadedFile = {
        name: lastFileMetadata.name,
        dateUploaded: new Date().toLocaleDateString(),
        lastUpdated: new Date().toLocaleDateString(),
        uploadedBy: 'Current User',
      };

      setUploadedFiles((prev) => [...prev, newUploadedFile]);
      await onUpload(processedData, lastFileMetadata);

      setUploadProgress(100);
      await new Promise((resolve) => setTimeout(resolve, 1000));
      setUploading(false);
      setFiles([]);
    } catch (error) {
      console.error('Upload error:', error);
      setError(error.message);
      setUploading(false);
    }
  };

  return (
    <div>
      <div
        className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer"
        onDrop={handleDrop}
        onDragOver={handleDragOver}
        onClick={() => document.getElementById('fileInput').click()}
      >
        <input
          data-testid="file-input"
          id="fileInput"
          type="file"
          multiple
          accept=".csv"
          onChange={handleFileChange}
          className="hidden"
        />
        <p className="text-lg mb-2">Click to upload or drag and drop</p>
        <p className="text-sm text-gray-500">CSV files only, maximum file size 50 MB</p>
      </div>
      {error && <p className="mt-4 text-red-500">{error}</p>}
      {files.length > 0 && (
        <div className="mt-4">
          <h3 className="font-semibold mb-2">Selected files:</h3>
          <ul className="list-disc pl-5">
            {files.map((file, index) => (
              <li key={index}>{file.name}</li>
            ))}
          </ul>
        </div>
      )}
      {uploading && (
        <div className="mt-4">
          <div className="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
            <div className="bg-blue-600 h-2.5 rounded-full" style={{ width: `${uploadProgress}%` }}></div>
          </div>
          <p className="text-center mt-2">{uploadProgress}% Uploaded</p>
        </div>
      )}
      <Button className="mt-4" onClick={handleUpload} disabled={files.length === 0 || uploading} data-testid="upload-button">
        {uploading ? 'Uploading...' : 'Upload File'}
      </Button>
      {uploadedFiles.length > 0 && (
        <Table className="mt-8">
          <TableHeader>
            <TableRow>
              <TableHead>File name</TableHead>
              <TableHead>Date uploaded</TableHead>
              <TableHead>Last updated</TableHead>
              <TableHead>Uploaded by</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {uploadedFiles.map((file, index) => (
              <TableRow key={index}>
                <TableCell>{file.name}</TableCell>
                <TableCell>{file.dateUploaded}</TableCell>
                <TableCell>{file.lastUpdated}</TableCell>
                <TableCell>{file.uploadedBy}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      )}
    </div>
  );
};

export default FileUpload;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/ErrorBoundary.jsx
```jsx
import React from 'react';
import logError from '@/lib/errorLogger';

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    this.setState({
      error: error,
      errorInfo: errorInfo
    });
    logError(error, {
      component: 'ErrorBoundary',
      errorInfo: errorInfo,
      additionalInfo: 'Uncaught error in component tree'
    });
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="p-4 bg-red-100 border border-red-400 text-red-700 rounded">
          <h2 className="text-lg font-semibold mb-2">Something went wrong</h2>
          <p className="mb-4">We're sorry, but an error occurred. Please try refreshing the page or contact support if the problem persists.</p>
          {process.env.NODE_ENV === 'development' && (
            <details className="whitespace-pre-wrap">
              {this.state.error && this.state.error.toString()}
              <br />
              {this.state.errorInfo && this.state.errorInfo.componentStack}
            </details>
          )}
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/Filter.jsx
```jsx
import React, { useState, useEffect, useContext, useMemo } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { HelpCircle, X } from 'lucide-react';
import { Tooltip } from "@/components/ui/tooltip";
import { Skeleton } from "@/components/ui/skeleton";
import RangeFilter from './RangeFilter';
import { DashboardContext } from '../context/DashboardContext';
import { useDebounce } from '../hooks/useDebounce';

const Filter = () => {
  const [activeTooltip, setActiveTooltip] = useState(null);
  const [activeFilters, setActiveFilters] = useState({});
  const [isLoading, setIsLoading] = useState(false);
  const { filters, setFilters, filterRanges, hasUploadedData, businessTypes } = useContext(DashboardContext);

  const debouncedSetFilters = useDebounce(setFilters, 300);

  useEffect(() => {
    const newActiveFilters = {};
    Object.entries(filters).forEach(([key, value]) => {
      if (Array.isArray(value) && (value[0] > filterRanges[key][0] || value[1] < filterRanges[key][1])) {
        newActiveFilters[key] = true;
      } else if (key === 'businessType' && value !== 'all') {
        newActiveFilters[key] = true;
      }
    });
    setActiveFilters(newActiveFilters);
  }, [filters, filterRanges]);

  const handleFilterChange = (key, newValue) => {
    setIsLoading(true);
    debouncedSetFilters(prevFilters => {
      setIsLoading(false);
      return { ...prevFilters, [key]: newValue };
    });
  };

  const handleResetFilter = (key) => {
    const resetValue = key === 'businessType' ? 'all' : filterRanges[key];
    handleFilterChange(key, resetValue);
  };

  const resetAllFilters = () => {
    setFilters({
      revenue: filterRanges.revenue,
      profit: filterRanges.profit,
      price: filterRanges.price,
      businessType: 'all',
    });
  };

  const generatePresets = (key) => {
    const [min, max] = filterRanges[key];
    const range = max - min;
    return [
      { label: `${min} - ${min + range * 0.25}`, min: min, max: min + range * 0.25 },
      { label: `${min + range * 0.25} - ${min + range * 0.5}`, min: min + range * 0.25, max: min + range * 0.5 },
      { label: `${min + range * 0.5} - ${min + range * 0.75}`, min: min + range * 0.5, max: min + range * 0.75 },
      { label: `${min + range * 0.75} - ${max}`, min: min + range * 0.75, max: max },
    ];
  };

  if (!hasUploadedData) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Filters</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex flex-col items-center justify-center h-64">
            <h3 className="text-xl font-semibold mb-2">No Data to Display</h3>
            <p className="text-gray-600 mb-4">Upload data from the File Management page to see available filters.</p>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex justify-between items-center">
          <span>Filters</span>
          <Button onClick={resetAllFilters} variant="outline" size="sm">
            Reset All Filters
          </Button>
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-8">
          <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
            {['revenue', 'profit', 'price'].map((key) => (
              <div key={key} className="space-y-2">
                <div className="h-8 flex items-center justify-between">
                  <h3 className="text-sm font-medium text-gray-700 flex items-center flex-1">
                    <span className="flex-grow capitalize">{key}</span>
                    <Tooltip content={`Set the ${key} range for startups to display`}>
                      <HelpCircle className="w-4 h-4 text-gray-400 cursor-help ml-2" />
                    </Tooltip>
                    <div className="w-8 h-8 flex items-center justify-center">
                      {activeFilters[key] && (
                        <Button
                          variant="outline"
                          size="sm"
                          className="px-1 py-0 bg-red-100 hover:bg-red-200 text-red-600"
                          onClick={() => handleResetFilter(key)}
                        >
                          <X className="h-4 w-4" />
                        </Button>
                      )}
                    </div>
                  </h3>
                </div>
                <div className="min-h-[180px]">
                  {isLoading ? (
                    <Skeleton className="h-[180px]" />
                  ) : (
                    <RangeFilter
                      label={`${key} Range`}
                      min={filterRanges[key][0]}
                      max={filterRanges[key][1]}
                      value={filters[key]}
                      onChange={(value) => handleFilterChange(key, value)}
                      presets={generatePresets(key)}
                    />
                  )}
                </div>
              </div>
            ))}
          </div>
          <div className="space-y-2">
            <div className="h-8 flex items-center justify-between">
              <h3 className="text-sm font-medium text-gray-700 flex items-center flex-1">
                <span className="flex-grow">Business Type</span>
                <Tooltip content="Filter startups by their business type">
                  <HelpCircle className="w-4 h-4 text-gray-400 cursor-help ml-2" />
                </Tooltip>
                <div className="w-8 h-8 flex items-center justify-center">
                  {activeFilters.businessType && (
                    <Button
                      variant="outline"
                      size="sm"
                      className="px-1 py-0 bg-red-100 hover:bg-red-200 text-red-600"
                      onClick={() => handleResetFilter('businessType')}
                    >
                      <X className="h-4 w-4" />
                    </Button>
                  )}
                </div>
              </h3>
            </div>
            <div className="min-h-[40px]">
              {isLoading ? (
                <Skeleton className="h-10" />
              ) : (
                <Select
                  value={filters.businessType}
                  onValueChange={(value) => handleFilterChange('businessType', value)}
                >
                  <SelectTrigger className="w-full">
                    <SelectValue placeholder="Select a business type" />
                  </SelectTrigger>
                  <SelectContent>
                    {businessTypes.map((type) => (
                      <SelectItem key={type} value={type}>
                        {type === 'all' ? 'All' : type}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              )}
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

export default Filter;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/SummaryStatistics.jsx
```jsx
import React from 'react';
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { formatCurrency } from "@/lib/utils";

const SummaryStatistics = ({ averageMetrics, hasUploadedData }) => {
  console.log('SummaryStatistics rendered with:', { averageMetrics, hasUploadedData });

  const renderMetric = (key, value) => {
    console.log(`Rendering metric: ${key} = ${value}`);
    return (
      <div key={key}>
        <p className="text-sm font-medium text-gray-500">{`Avg ${key.replace('avg', '')}`}</p>
        <p className="mt-1 text-2xl sm:text-3xl font-semibold text-gray-900">
          {key.includes('PriceTo')
            ? value // Already formatted in Dashboard.jsx
            : typeof value === 'number'
              ? formatCurrency(value)
              : value || 'N/A'}
        </p>
      </div>
    );
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>
          Summary Statistics
        </CardTitle>
      </CardHeader>
      <CardContent className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4">
        {!hasUploadedData ? (
          <div className="flex flex-col items-center justify-center h-64 col-span-full">
            <h3 className="text-xl font-semibold mb-2">No Data Available</h3>
            <p className="text-gray-600 mb-4">Upload data from the File Management page to see summary statistics.</p>
          </div>
        ) : (
          <>
            {averageMetrics && typeof averageMetrics === 'object' ? (
              Object.entries(averageMetrics).map(([key, value]) => renderMetric(key, value))
            ) : (
              <div className="col-span-full">
                <p>No metrics available</p>
              </div>
            )}
          </>
        )}
      </CardContent>
    </Card>
  );
};

export default SummaryStatistics;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/ProfitVsPriceChart.jsx
```jsx
import React, { useMemo, useContext, useState, useCallback } from 'react';
import { ScatterChart, Scatter, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';
import { formatCompactNumber, formatCurrency } from '@/lib/utils';
import { DashboardContext } from '@/context/DashboardContext';

const CHUNK_SIZE = 100;

const ProfitVsPriceChart = () => {
  const { data, filters } = useContext(DashboardContext);
  const [displayedData, setDisplayedData] = useState([]);
  const [isLoading, setIsLoading] = useState(false);

  const filteredData = useMemo(() => {
    return data.filter(item =>
      (!filters.revenue || (item['TTM Revenue'] >= filters.revenue[0] && item['TTM Revenue'] <= filters.revenue[1])) &&
      (!filters.profit || (item['TTM Profit'] >= filters.profit[0] && item['TTM Profit'] <= filters.profit[1])) &&
      (!filters.price || (item['Asking Price'] >= filters.price[0] && item['Asking Price'] <= filters.price[1])) &&
      (!filters.businessType || filters.businessType === 'all' || item['Business Type'] === filters.businessType)
    );
  }, [data, filters]);

  const loadChunk = useCallback((startIndex) => {
    return new Promise((resolve) => {
      setTimeout(() => {
        const chunk = filteredData.slice(startIndex, startIndex + CHUNK_SIZE);
        resolve(chunk);
      }, 0);
    });
  }, [filteredData]);

  const loadData = useCallback(async () => {
    setIsLoading(true);
    setDisplayedData([]);
    
    for (let i = 0; i < filteredData.length; i += CHUNK_SIZE) {
      const chunk = await loadChunk(i);
      setDisplayedData(prev => [...prev, ...chunk]);
    }
    
    setIsLoading(false);
  }, [filteredData, loadChunk]);

  React.useEffect(() => {
    loadData();
  }, [loadData]);

  const calculateDomain = useCallback((data, key, buffer = 0.1) => {
    if (data.length === 0) return [0, 1];
    const values = data.map(item => Number(item[key]));
    const minValue = Math.min(...values);
    const maxValue = Math.max(...values);
    const range = maxValue - minValue;
    return [
      minValue < 0 ? minValue - Math.abs(range * buffer) : Math.max(0, minValue - range * buffer),
      maxValue + range * buffer
    ];
  }, []);

  const domains = useMemo(() => ({
    profit: calculateDomain(displayedData, 'TTM Profit'),
    price: calculateDomain(displayedData, 'Asking Price')
  }), [displayedData, calculateDomain]);

  if (isLoading) {
    return <div className="h-[300px] flex items-center justify-center">Loading chart data...</div>;
  }

  return (
    <ResponsiveContainer width="100%" height={300}>
      <ScatterChart margin={{ top: 20, right: 20, bottom: 20, left: 80 }}>
        <CartesianGrid />
        <XAxis
          type="number"
          dataKey="TTM Profit"
          name="Profit"
          unit="$"
          domain={domains.profit}
          tickFormatter={(value) => formatCompactNumber(value)}
        />
        <YAxis
          type="number"
          dataKey="Asking Price"
          name="Price"
          unit="$"
          domain={domains.price}
          tickFormatter={(value) => formatCompactNumber(value)}
        />
        <Tooltip
          formatter={(value, name) => [formatCurrency(value), name]}
          labelFormatter={() => ''}
        />
        <Scatter name="Profit vs Price" data={displayedData} fill="#82ca9d" />
      </ScatterChart>
    </ResponsiveContainer>
  );
};

export default React.memo(ProfitVsPriceChart);
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/Sidebar.jsx
```jsx
import React from 'react';
import { Link, useLocation } from 'react-router-dom';
import { Home, FileText, Upload } from 'lucide-react';
import { motion } from 'framer-motion';
import { Button } from "@/components/ui/button";

const Sidebar = () => {
  const location = useLocation();

  const isActive = (path) => {
    return location.pathname === path ? 'bg-gray-200 text-gray-900' : 'text-gray-600 hover:bg-gray-100 hover:text-gray-900';
  };

  return (
    <div className="flex flex-col w-64 bg-white border-r border-gray-200 h-screen">
      <div className="flex items-center justify-center h-16 border-b border-gray-200">
        <span className="text-gray-900 font-bold text-lg">Micro Startup Dashboard</span>
      </div>
      <nav className="flex-1">
        <ul className="space-y-2 py-4">
          <li>
            <Link to="/" className={`flex items-center px-4 py-2 text-sm font-medium ${isActive('/')}`}>
              <Home className="mr-3 h-6 w-6" />
              Dashboard
            </Link>
          </li>
          <li>
            <Link to="/file-management" className={`flex items-center px-4 py-2 text-sm font-medium ${isActive('/file-management')}`}>
              <FileText className="mr-3 h-6 w-6" />
              File Management
            </Link>
          </li>
        </ul>
      </nav>
      <div className="p-4 space-y-2">
        <h3 className="text-sm font-semibold text-gray-600 mb-2">Quick Actions</h3>
        <motion.div whileHover={{ scale: 1.05 }} whileTap={{ scale: 0.95 }}>
          <Link to="/file-management">
            <Button
              className="w-full flex items-center justify-center"
            >
              <Upload className="mr-2 h-4 w-4" />
              Upload File
            </Button>
          </Link>
        </motion.div>
      </div>
    </div>
  );
};

export default Sidebar;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/Dashboard.jsx
```jsx
import React, { useState, useEffect, useContext, useMemo, useCallback } from 'react';
import { HelpCircle } from 'lucide-react';
import { formatCurrency, calculateFinancialRatio, formatRatio } from "@/lib/utils";
import logError from "@/lib/errorLogger";
import Filter from './Filter';
import StartupDetailsTable from './StartupDetailsTable';
import RevenueVsPriceChart from './RevenueVsPriceChart';
import ProfitVsPriceChart from './ProfitVsPriceChart';
import SummaryStatistics from './SummaryStatistics';
import { DashboardContext } from '../context/DashboardContext';
import { Card, CardHeader, CardTitle, CardContent } from './ui/card';

const Dashboard = ({ isLoading }) => {
  console.log('Dashboard rendering. isLoading:', isLoading);

  const [activeTooltip, setActiveTooltip] = useState(null);
  const [sortConfig, setSortConfig] = useState({ key: null, direction: 'ascending' });
  const [error, setError] = useState(null);
  const { data, filters, updateFilterRanges, hasUploadedData } = useContext(DashboardContext);

  console.log('Dashboard data:', data);
  console.log('Has uploaded data:', hasUploadedData);

  const processData = useCallback(() => {
    try {
      console.log('Processing data. Data length:', data.length);
      // If data changes and we have data, ensure filter ranges are up to date.
      // This is optional since we updateFilterRanges in FileManagementContainer on file selection.
      // But we can keep it as a safety net.
      if (data.length > 0) {
        updateFilterRanges(data);
      }
    } catch (err) {
      logError(err, { component: 'Dashboard', function: 'processData' });
      setError('An error occurred while processing the data. Please try again.');
    }
  }, [data, updateFilterRanges]);

  useEffect(() => {
    processData();
  }, [processData]);

  const generateReport = useCallback(() => {
    console.log('Generating report');
    // Implement report generation logic here
  }, []);

  const averageMetrics = useMemo(() => {
    if (!hasUploadedData || data.length === 0) {
      return {
        avgRevenue: 0,
        avgProfit: 0,
        avgPrice: 0,
        avgPriceToRevenue: 'N/A',
        avgPriceToProfit: 'N/A',
      };
    }

    const sum = data.reduce((acc, item) => {
      acc.revenue += Number(item['TTM Revenue']) || 0;
      acc.profit += Number(item['TTM Profit']) || 0;
      acc.price += Number(item['Asking Price']) || 0;
      return acc;
    }, { revenue: 0, profit: 0, price: 0 });

    const count = data.length;
    const avgRevenue = sum.revenue / count;
    const avgProfit = sum.profit / count;
    const avgPrice = sum.price / count;

    console.log('Average calculations:', { avgRevenue, avgProfit, avgPrice });

    const avgPriceToRevenue = avgRevenue !== 0 ? avgPrice / avgRevenue : 0;
    const avgPriceToProfit = avgProfit !== 0 ? avgPrice / avgProfit : 0;

    console.log('Ratio calculations:', { avgPriceToRevenue, avgPriceToProfit });

    return {
      avgRevenue,
      avgProfit,
      avgPrice,
      avgPriceToRevenue: formatRatio(avgPriceToRevenue),
      avgPriceToProfit: formatRatio(avgPriceToProfit),
    };
  }, [data, hasUploadedData]);

  console.log('Calculated average metrics:', averageMetrics);

  const ContextualHelp = ({ id, content }) => (
    <div className="relative inline-block ml-2">
      <HelpCircle
        className="w-4 h-4 text-gray-400 cursor-help"
        onMouseEnter={() => setActiveTooltip(id)}
        onMouseLeave={() => setActiveTooltip(null)}
      />
      {activeTooltip === id && (
        <div className="absolute z-10 w-64 p-2 mt-2 text-sm bg-white rounded-md shadow-lg border border-gray-200">
          {content}
        </div>
      )}
    </div>
  );

  const EmptyStateMessage = ({ title, message }) => (
    <div className="flex flex-col items-center justify-center h-64">
      <h3 className="text-xl font-semibold mb-2">{title}</h3>
      <p className="text-gray-600 mb-4">{message}</p>
    </div>
  );

  return (
    <div className="p-4 space-y-4">
      <h1 className="text-2xl font-bold mb-4">Dashboard 2.0</h1>
      {isLoading ? (
        <div className="flex items-center justify-center h-64">
          <p className="text-xl font-semibold">Loading data...</p>
        </div>
      ) : (
        <>
          <Filter />

          <SummaryStatistics
            averageMetrics={averageMetrics}
            hasUploadedData={hasUploadedData}
            generateReport={generateReport}
          />

          <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
            <Card>
              <CardHeader>
                <CardTitle>
                  Revenue vs Price
                  <ContextualHelp
                    id="help-revenue-price"
                    content="This chart shows the relationship between a startup's revenue and its asking price"
                  />
                </CardTitle>
              </CardHeader>
              <CardContent>
                {!hasUploadedData ? (
                  <EmptyStateMessage
                    title="No Data to Display"
                    message="Upload data from the File Management page to see the Revenue vs Price chart."
                  />
                ) : (
                  <RevenueVsPriceChart />
                )}
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <CardTitle>
                  Profit vs Price
                  <ContextualHelp
                    id="help-profit-price"
                    content="This chart shows the relationship between a startup's profit and its asking price"
                  />
                </CardTitle>
              </CardHeader>
              <CardContent>
                {!hasUploadedData ? (
                  <EmptyStateMessage
                    title="No Data to Display"
                    message="Upload data from the File Management page to see the Profit vs Price chart."
                  />
                ) : (
                  <ProfitVsPriceChart />
                )}
              </CardContent>
            </Card>
          </div>

          <Card>
            <CardHeader>
              <CardTitle>
                Startup Details
                <ContextualHelp
                  id="help-startup-details"
                  content="This table shows detailed information for each startup matching your filters"
                />
              </CardTitle>
            </CardHeader>
            <CardContent>
              {!hasUploadedData ? (
                <EmptyStateMessage
                  title="No Startup Data Available"
                  message="Upload data from the File Management page to see detailed startup information."
                />
              ) : (
                <StartupDetailsTable
                  onSort={(key) => setSortConfig({
                    key,
                    direction: sortConfig.direction === 'ascending' ? 'descending' : 'ascending'
                  })}
                  sortConfig={sortConfig}
                />
              )}
            </CardContent>
          </Card>
        </>
      )}
    </div>
  );
};

export default Dashboard;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/RangeFilter.jsx
```jsx
import React, { useState, useEffect } from 'react';
import * as SliderPrimitive from "@radix-ui/react-slider";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { formatCurrency } from '@/lib/utils';

const RangeFilter = ({ label, min, max, value, onChange, presets }) => {
  const [error, setError] = useState('');
  const [selectedPreset, setSelectedPreset] = useState(null);

  // Ensure that min, max, and value are valid before rendering
  if (min === undefined || max === undefined || !Array.isArray(value) || value.length !== 2) {
    console.error('Invalid props provided to RangeFilter:', { min, max, value });
    return null; // or return an error message
  }

  const handleInputChange = (index) => (e) => {
    const newValue = e.target.value === '' ? '' : Number(e.target.value);
    const updatedValue = [...value];
    updatedValue[index] = newValue;
    validateAndUpdate(updatedValue);
    setSelectedPreset(null);
  };

  const validateAndUpdate = (newValue) => {
    const [newMin, newMax] = newValue;
    if (newMin > newMax) {
      setError('Min value cannot be greater than max value');
    } else if (newMin < min || newMax > max) {
      setError(`Values must be between ${formatCurrency(min)} and ${formatCurrency(max)}`);
    } else {
      setError('');
      onChange(newValue);
    }
  };

  const handlePresetClick = (presetMin, presetMax, index) => {
    if (selectedPreset === index) {
      // If the preset is already selected, reset to the full range
      validateAndUpdate([min, max]);
      setSelectedPreset(null);
    } else {
      validateAndUpdate([presetMin, presetMax]);
      setSelectedPreset(index);
    }
  };

  const normalizeValue = (val) => {
    return ((val - min) / (max - min)) * 100;
  };

  const handleSliderChange = (newValue) => {
    const denormalizedValue = newValue.map((normalizedValue) => {
      return (normalizedValue / 100) * (max - min) + min;
    });
    validateAndUpdate(denormalizedValue);
    setSelectedPreset(null);
  };

  useEffect(() => {
    // Check if current value matches any preset
    const matchingPresetIndex = presets.findIndex(
      preset => preset.min === value[0] && preset.max === value[1]
    );
    setSelectedPreset(matchingPresetIndex !== -1 ? matchingPresetIndex : null);
  }, [value, presets]);

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <span className="text-sm font-medium text-gray-700">{label}</span>
        <span className="text-sm text-gray-500">
          {formatCurrency(value[0])} - {formatCurrency(value[1])}
        </span>
      </div>
      <SliderPrimitive.Root
        min={0}
        max={100}
        step={0.1}
        value={[normalizeValue(value[0]), normalizeValue(value[1])]}
        onValueChange={handleSliderChange}
        className="relative flex items-center w-full h-5 touch-none"
        aria-label={`${label} range`}
      >
        <SliderPrimitive.Track className="relative w-full h-2 grow rounded-full bg-gray-200">
          <SliderPrimitive.Range className="absolute h-full rounded-full bg-blue-500" />
        </SliderPrimitive.Track>
        <SliderPrimitive.Thumb
          className="block w-5 h-5 rounded-full bg-white border-2 border-blue-500 focus:outline-none focus-visible:ring focus-visible:ring-blue-300"
          aria-label={`${label} minimum value`}
        />
        <SliderPrimitive.Thumb
          className="block w-5 h-5 rounded-full bg-white border-2 border-blue-500 focus:outline-none focus-visible:ring focus-visible:ring-blue-300"
          aria-label={`${label} maximum value`}
        />
      </SliderPrimitive.Root>
      <div className="flex items-center space-x-4">
        <Input
          type="number"
          value={value[0]}
          onChange={handleInputChange(0)}
          className="w-24"
          aria-label={`Minimum ${label}`}
        />
        <span className="text-gray-500">to</span>
        <Input
          type="number"
          value={value[1]}
          onChange={handleInputChange(1)}
          className="w-24"
          aria-label={`Maximum ${label}`}
        />
      </div>
      {error && <p className="text-red-500 text-sm" role="alert">{error}</p>}
      <div className="flex flex-wrap gap-2">
        {presets.map((preset, index) => (
          <Button
            key={index}
            size="sm"
            onClick={() => handlePresetClick(preset.min, preset.max, index)}
            className={`transition-colors ${
              selectedPreset === index
                ? "bg-blue-500 text-white hover:bg-blue-600"
                : "bg-white text-gray-700 border border-gray-300 hover:bg-gray-100"
            }`}
          >
            {preset.label}
          </Button>
        ))}
      </div>
    </div>
  );
};

export default RangeFilter;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/TableHeader.jsx
```jsx
import React from 'react';
import { Info, ArrowUpDown } from 'lucide-react';
import { Tooltip } from "@/components/ui/tooltip";

const TableHeader = ({ sortConfig, onSort }) => {
  const HeaderCell = ({ label, sortKey, tooltip }) => (
    <div 
      className={`flex-1 px-4 py-2 font-medium cursor-pointer transition-colors hover:bg-gray-100 ${
        sortConfig.key === sortKey ? 'bg-blue-50' : ''
      }`}
      onClick={() => onSort(sortKey)}
    >
      <div className="flex items-center justify-between">
        <span>{label}</span>
        <div className="flex items-center">
          {tooltip && (
            <Tooltip content={tooltip}>
              <Info className="h-4 w-4 text-gray-400 mr-1" />
            </Tooltip>
          )}
          <ArrowUpDown className={`h-4 w-4 transition-transform ${
            sortConfig.key === sortKey 
              ? sortConfig.direction === 'ascending' 
                ? 'text-blue-500 rotate-180' 
                : 'text-blue-500'
              : 'text-gray-300'
          }`} />
        </div>
      </div>
    </div>
  );

  return (
    <div className="flex border-b bg-white sticky top-0 z-10">
      <HeaderCell label="Business Type" sortKey="Business Type" tooltip="Type of business" />
      <HeaderCell label="TTM Revenue" sortKey="TTM Revenue" tooltip="Trailing Twelve Months Revenue" />
      <HeaderCell label="TTM Profit" sortKey="TTM Profit" tooltip="Trailing Twelve Months Profit" />
      <HeaderCell label="Asking Price" sortKey="Asking Price" tooltip="Requested selling price" />
      <HeaderCell label="Price to Revenue" sortKey="price to revenue" tooltip="Asking Price / TTM Revenue" />
      <HeaderCell label="Price-to-Profit" sortKey="price-to-profit" tooltip="Asking Price / TTM Profit" />
      <div className="flex-1 px-4 py-2 font-medium">View</div>
      <div className="flex-1 px-4 py-2 font-medium">Actions</div>
    </div>
  );
};

export default React.memo(TableHeader);
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/FileUpload.test.jsx
```jsx
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';
import FileUpload from './FileUpload';

// Mock Papa Parse
jest.mock('papaparse', () => ({
  parse: jest.fn((file, config) => {
    config.complete({
      data: [{ col1: 'test', col2: 'data' }],
    });
  }),
}));

describe('FileUpload Component', () => {
  const mockOnUpload = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('renders without crashing', () => {
    render(<FileUpload onUpload={mockOnUpload} />);
    expect(screen.getByText('Files and assets')).toBeInTheDocument();
  });

  test('handles file selection', () => {
    render(<FileUpload onUpload={mockOnUpload} />);
    const input = screen.getByTestId('file-input');
    const file = new File(['test'], 'test.csv', { type: 'text/csv' });

    fireEvent.change(input, { target: { files: [file] } });

    expect(screen.getByText('test.csv')).toBeInTheDocument();
  });

  test('displays error for non-CSV files', () => {
    render(<FileUpload onUpload={mockOnUpload} />);
    const input = screen.getByTestId('file-input');
    const file = new File(['test'], 'test.txt', { type: 'text/plain' });

    fireEvent.change(input, { target: { files: [file] } });
    fireEvent.click(screen.getByText('Upload File'));

    expect(screen.getByText(/unsupported file type/i)).toBeInTheDocument();
  });

  test('uploads file and shows progress', async () => {
    render(<FileUpload onUpload={mockOnUpload} />);
    const input = screen.getByTestId('file-input');
    const file = new File(['test'], 'test.csv', { type: 'text/csv' });

    fireEvent.change(input, { target: { files: [file] } });
    fireEvent.click(screen.getByText('Upload File'));

    await waitFor(() => {
      expect(screen.getByText('100% Uploaded')).toBeInTheDocument();
    });

    expect(mockOnUpload).toHaveBeenCalled();
  });

  test('displays uploaded files in the table', async () => {
    render(<FileUpload onUpload={mockOnUpload} />);
    const input = screen.getByTestId('file-input');
    const file = new File(['test'], 'test.csv', { type: 'text/csv' });

    fireEvent.change(input, { target: { files: [file] } });
    fireEvent.click(screen.getByText('Upload File'));

    await waitFor(() => {
      expect(screen.getAllByText('test.csv').length).toBeGreaterThan(0);
      expect(screen.getByText('Current User')).toBeInTheDocument();
    });
  });

  test('handles drag and drop', () => {
    render(<FileUpload onUpload={mockOnUpload} />);
    const dropzone = screen.getByText(/Click to upload or drag and drop/i);
    const file = new File(['test'], 'test.csv', { type: 'text/csv' });

    fireEvent.drop(dropzone, {
      dataTransfer: {
        files: [file],
      },
    });

    expect(screen.getByText('test.csv')).toBeInTheDocument();
  });
});
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/Pagination.jsx
```jsx
import React from 'react';
import { Button } from "@/components/ui/button";
import { ChevronLeft, ChevronRight } from 'lucide-react';

const Pagination = ({ 
  currentPage, 
  totalPages, 
  pageSize, 
  totalRecords,
  onPageChange, 
  onPageSizeChange 
}) => {
  const pageSizes = [25, 50, 100];
  
  const getPageNumbers = () => {
    const delta = 2;
    const range = [];
    const rangeWithDots = [];
    let l;

    for (let i = 1; i <= totalPages; i++) {
      if (i === 1 || i === totalPages || (i >= currentPage - delta && i <= currentPage + delta)) {
        range.push(i);
      }
    }

    range.forEach(i => {
      if (l) {
        if (i - l === 2) {
          rangeWithDots.push(l + 1);
        } else if (i - l !== 1) {
          rangeWithDots.push('...');
        }
      }
      rangeWithDots.push(i);
      l = i;
    });

    return rangeWithDots;
  };

  return (
    <div className="flex items-center justify-between px-2 py-3 space-x-4">
      <div className="flex items-center space-x-2">
        <span className="text-sm text-gray-700">Show</span>
        <select
          value={pageSize}
          onChange={(e) => onPageSizeChange(Number(e.target.value))}
          className="border rounded p-1 text-sm"
        >
          {pageSizes.map(size => (
            <option key={size} value={size}>{size}</option>
          ))}
        </select>
        <span className="text-sm text-gray-700">entries</span>
      </div>

      <div className="flex items-center space-x-1">
        <Button
          variant="outline"
          size="sm"
          onClick={() => onPageChange(currentPage - 1)}
          disabled={currentPage === 1}
        >
          <ChevronLeft className="h-4 w-4" />
        </Button>

        {getPageNumbers().map((page, index) => (
          <React.Fragment key={index}>
            {page === '...' ? (
              <span className="px-2">...</span>
            ) : (
              <Button
                variant={currentPage === page ? 'default' : 'outline'}
                size="sm"
                onClick={() => onPageChange(page)}
              >
                {page}
              </Button>
            )}
          </React.Fragment>
        ))}

        <Button
          variant="outline"
          size="sm"
          onClick={() => onPageChange(currentPage + 1)}
          disabled={currentPage === totalPages}
        >
          <ChevronRight className="h-4 w-4" />
        </Button>
      </div>

      <div className="text-sm text-gray-700">
        Showing {Math.min((currentPage - 1) * pageSize + 1, totalRecords)} to{' '}
        {Math.min(currentPage * pageSize, totalRecords)} of {totalRecords} entries
      </div>
    </div>
  );
};

export default React.memo(Pagination);
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/LazyChart.jsx
```jsx
import React, { Suspense } from 'react';
import { Skeleton } from "@/components/ui/skeleton";

const LazyChart = ({ Chart, data, height = 300 }) => {
  return (
    <Suspense fallback={<Skeleton className={`w-full h-${height}`} />}>
      <Chart data={data} />
    </Suspense>
  );
};

export default LazyChart;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/StartupDetailsTable.jsx
```jsx
import React, { useState, useEffect, useContext, useMemo, useCallback } from 'react';
import { FixedSizeList as List } from 'react-window';
import InfiniteLoader from 'react-window-infinite-loader';
import AutoSizer from 'react-virtualized/dist/commonjs/AutoSizer';
import { DashboardContext } from '@/context/DashboardContext';
import { calculateFinancialRatioAsNumber } from "@/lib/utils";
import TableHeader from './TableHeader';
import VirtualRow from './VirtualRow';
import Pagination from './Pagination';

const ROW_HEIGHT = 48;

const StartupDetailsTable = ({ onSort, sortConfig }) => {
  const { data, filters, removeListingFromData } = useContext(DashboardContext);
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize, setPageSize] = useState(25);
  const [isNextPageLoading, setIsNextPageLoading] = useState(false);
  
  const filteredData = useMemo(() => {
    return data.filter(item =>
      (!filters.revenue || (item['TTM Revenue'] >= filters.revenue[0] && item['TTM Revenue'] <= filters.revenue[1])) &&
      (!filters.profit || (item['TTM Profit'] >= filters.profit[0] && item['TTM Profit'] <= filters.profit[1])) &&
      (!filters.price || (item['Asking Price'] >= filters.price[0] && item['Asking Price'] <= filters.price[1])) &&
      (!filters.businessType || filters.businessType === 'all' || item['Business Type'] === filters.businessType)
    );
  }, [data, filters]);

  const sortedData = useMemo(() => {
    let sortableItems = [...filteredData];
    if (sortConfig.key !== null) {
      sortableItems.sort((a, b) => {
        let aValue, bValue;

        if (sortConfig.key === 'price to revenue') {
          aValue = calculateFinancialRatioAsNumber(a['Asking Price'], a['TTM Revenue']);
          bValue = calculateFinancialRatioAsNumber(b['Asking Price'], b['TTM Revenue']);
        } else if (sortConfig.key === 'price-to-profit') {
          aValue = calculateFinancialRatioAsNumber(a['Asking Price'], a['TTM Profit']);
          bValue = calculateFinancialRatioAsNumber(b['Asking Price'], b['TTM Profit']);
        } else {
          aValue = typeof a[sortConfig.key] === 'string' && !isNaN(a[sortConfig.key].replace(/[^0-9.-]+/g, ""))
            ? parseFloat(a[sortConfig.key].replace(/[^0-9.-]+/g, ""))
            : a[sortConfig.key];
          bValue = typeof b[sortConfig.key] === 'string' && !isNaN(b[sortConfig.key].replace(/[^0-9.-]+/g, ""))
            ? parseFloat(b[sortConfig.key].replace(/[^0-9.-]+/g, ""))
            : b[sortConfig.key];
        }

        if (aValue === null || aValue === 0) return sortConfig.direction === 'ascending' ? 1 : -1;
        if (bValue === null || bValue === 0) return sortConfig.direction === 'ascending' ? -1 : 1;

        return sortConfig.direction === 'ascending' ? aValue - bValue : bValue - aValue;
      });
    }
    return sortableItems;
  }, [filteredData, sortConfig]);

  // Calculate the current page's data
  const currentPageData = useMemo(() => {
    const startIndex = (currentPage - 1) * pageSize;
    const endIndex = startIndex + pageSize;
    return sortedData.slice(startIndex, endIndex);
  }, [sortedData, currentPage, pageSize]);

  const handlePageChange = useCallback((page) => {
    setCurrentPage(page);
  }, []);

  const handlePageSizeChange = useCallback((newSize) => {
    setPageSize(newSize);
    setCurrentPage(1); // Reset to first page when changing page size
  }, []);

  const handleRemove = useCallback((id) => {
    setTimeout(() => {
      removeListingFromData(id);
    }, 300);
  }, [removeListingFromData]);

  // Reset to first page when filtered data changes
  useEffect(() => {
    setCurrentPage(1);
  }, [filteredData.length]);

  const loadMoreItems = useCallback(async (startIndex, stopIndex) => {
    setIsNextPageLoading(true);
    await new Promise(resolve => setTimeout(resolve, 100));
    setIsNextPageLoading(false);
  }, []);

  const isItemLoaded = useCallback(index => {
    return index < currentPageData.length;
  }, [currentPageData.length]);

  return (
    <div className="h-[600px] relative">
      <TableHeader sortConfig={sortConfig} onSort={onSort} />

      <div className="h-[500px]">
        <AutoSizer>
          {({ height, width }) => (
            <InfiniteLoader
              isItemLoaded={isItemLoaded}
              itemCount={currentPageData.length}
              loadMoreItems={loadMoreItems}
              minimumBatchSize={pageSize}
            >
              {({ onItemsRendered, ref }) => (
                <List
                  ref={ref}
                  height={height}
                  itemCount={currentPageData.length}
                  itemSize={ROW_HEIGHT}
                  width={width}
                  onItemsRendered={onItemsRendered}
                >
                  {({ index, style }) => (
                    <VirtualRow
                      index={index}
                      style={style}
                      data={currentPageData}
                      onRemove={handleRemove}
                    />
                  )}
                </List>
              )}
            </InfiniteLoader>
          )}
        </AutoSizer>
      </div>

      <Pagination
        currentPage={currentPage}
        totalPages={Math.ceil(sortedData.length / pageSize)}
        pageSize={pageSize}
        totalRecords={sortedData.length}
        onPageChange={handlePageChange}
        onPageSizeChange={handlePageSizeChange}
      />
    </div>
  );
};

export default React.memo(StartupDetailsTable);
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/FileManagementContainer.jsx
```jsx
// FileManagementContainer.jsx
import React, { useContext, useCallback } from 'react';
import MultiFileUpload from './MultiFileUpload';
import FileList from './FileList';
import { DashboardContext } from '../context/DashboardContext';

const FileManagementContainer = () => {
    const { files, setFiles, selectedFileId, setSelectedFileId, setFilters, updateFilterRanges, data } = useContext(DashboardContext);

    const handleFilesUploaded = useCallback((uploadedFiles) => {
        // Add new files to context
        setFiles(prev => [...prev, ...uploadedFiles]);
        // If this is the first upload or no file is selected, select the first of the newly uploaded
        if (uploadedFiles.length > 0 && !selectedFileId) {
            setSelectedFileId(uploadedFiles[0].id);
            // Update filter ranges based on the newly selected file's data
            updateFilterRanges(uploadedFiles[0].data);
        }
    }, [selectedFileId, setSelectedFileId, setFiles, updateFilterRanges]);

    const handleSelectFile = (id) => {
        setSelectedFileId(id);
        const file = files.find(f => f.id === id);
        if (file && file.data) {
            updateFilterRanges(file.data);
        } else {
            // If no file or data, reset filters
            updateFilterRanges([]);
        }
    };

    const handleDeleteFile = (id) => {
        // Remove file from context
        setFiles(prev => prev.filter(f => f.id !== id));
        if (id === selectedFileId) {
            // If deleting the currently selected file
            setSelectedFileId(null);
            // With no selected file, update filters with empty data
            updateFilterRanges([]);
        }
    };

    return (
        <div className="flex flex-col md:flex-row p-4">
            <FileList
                files={files}
                selectedFileId={selectedFileId}
                onSelectFile={handleSelectFile}
                onDeleteFile={handleDeleteFile}
            />
            <div className="w-full md:w-3/4 p-4">
                <MultiFileUpload onFilesUploaded={handleFilesUploaded} />
            </div>
        </div>
    );
};

export default FileManagementContainer;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/FileManagement.jsx
```jsx
import React from 'react';
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import FileManagementContainer from './FileManagementContainer';

const FileManagement = () => {
  return (
    <div className="p-4 space-y-4">
      <h1 className="text-2xl font-bold mb-4">File Management</h1>
      <Card>
        <CardHeader>
          <CardTitle>Files and Assets</CardTitle>
        </CardHeader>
        <CardContent>
          <FileManagementContainer />
        </CardContent>
      </Card>
    </div>
  );
};

export default FileManagement;
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/RevenueVsPriceChart.jsx
```jsx
import React, { useMemo, useContext, useState, useCallback } from 'react';
import { ScatterChart, Scatter, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';
import { formatCompactNumber, formatCurrency } from '@/lib/utils';
import { DashboardContext } from '@/context/DashboardContext';

const CHUNK_SIZE = 100;

const RevenueVsPriceChart = () => {
  const { data, filters } = useContext(DashboardContext);
  const [displayedData, setDisplayedData] = useState([]);
  const [isLoading, setIsLoading] = useState(false);

  const filteredData = useMemo(() => {
    return data.filter(item =>
      (!filters.revenue || (item['TTM Revenue'] >= filters.revenue[0] && item['TTM Revenue'] <= filters.revenue[1])) &&
      (!filters.profit || (item['TTM Profit'] >= filters.profit[0] && item['TTM Profit'] <= filters.profit[1])) &&
      (!filters.price || (item['Asking Price'] >= filters.price[0] && item['Asking Price'] <= filters.price[1])) &&
      (!filters.businessType || filters.businessType === 'all' || item['Business Type'] === filters.businessType)
    );
  }, [data, filters]);

  const loadChunk = useCallback((startIndex) => {
    return new Promise((resolve) => {
      setTimeout(() => {
        const chunk = filteredData.slice(startIndex, startIndex + CHUNK_SIZE);
        resolve(chunk);
      }, 0);
    });
  }, [filteredData]);

  const loadData = useCallback(async () => {
    setIsLoading(true);
    setDisplayedData([]);
    
    for (let i = 0; i < filteredData.length; i += CHUNK_SIZE) {
      const chunk = await loadChunk(i);
      setDisplayedData(prev => [...prev, ...chunk]);
    }
    
    setIsLoading(false);
  }, [filteredData, loadChunk]);

  React.useEffect(() => {
    loadData();
  }, [loadData]);

  const calculateDomain = useCallback((data, key, buffer = 0.1, allowNegative = false) => {
    if (data.length === 0) return [0, 1];
    const minValue = allowNegative ? Math.min(...data.map(item => item[key])) : Math.max(0, Math.min(...data.map(item => item[key])));
    const maxValue = Math.max(...data.map(item => item[key]));
    const range = maxValue - minValue;
    return [
      minValue - (allowNegative ? range * buffer : 0),
      maxValue + range * buffer
    ];
  }, []);

  const domains = useMemo(() => ({
    revenue: calculateDomain(displayedData, 'TTM Revenue', 0.1, false),
    price: calculateDomain(displayedData, 'Asking Price', 0.1, true)
  }), [displayedData, calculateDomain]);

  if (isLoading) {
    return <div className="h-[300px] flex items-center justify-center">Loading chart data...</div>;
  }

  return (
    <ResponsiveContainer width="100%" height={300}>
      <ScatterChart margin={{ top: 20, right: 20, bottom: 20, left: 80 }}>
        <CartesianGrid />
        <XAxis
          type="number"
          dataKey="TTM Revenue"
          name="Revenue"
          unit="$"
          domain={domains.revenue}
          tickFormatter={(value) => formatCompactNumber(value)}
        />
        <YAxis
          type="number"
          dataKey="Asking Price"
          name="Price"
          unit="$"
          domain={domains.price}
          tickFormatter={(value) => formatCompactNumber(value)}
        />
        <Tooltip
          formatter={(value, name) => [formatCurrency(value), name]}
          labelFormatter={() => ''}
        />
        <Scatter name="Revenue vs Price" data={displayedData} fill="#8884d8" />
      </ScatterChart>
    </ResponsiveContainer>
  );
};

export default React.memo(RevenueVsPriceChart);
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/components/VirtualTable.jsx
```jsx
import React, { useCallback } from 'react';
import { FixedSizeList as List } from 'react-window';
import AutoSizer from 'react-virtualized/dist/commonjs/AutoSizer';
import { TableRow, TableCell } from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Trash2, ExternalLink } from 'lucide-react';
import { formatCurrency, calculateFinancialRatio } from "@/lib/utils";

const ROW_HEIGHT = 48;

const VirtualTable = ({ data, onRemove }) => {
  const Row = useCallback(({ index, style }) => {
    const item = data[index];
    return (
      <TableRow 
        style={style}
        className={`${index % 2 === 0 ? 'bg-gray-50' : ''} absolute w-full`}
      >
        <TableCell>{item['Business Type']}</TableCell>
        <TableCell className="text-right">{formatCurrency(item['TTM Revenue'])}</TableCell>
        <TableCell className="text-right">{formatCurrency(item['TTM Profit'])}</TableCell>
        <TableCell className="text-right">{formatCurrency(item['Asking Price'])}</TableCell>
        <TableCell className="text-right">{calculateFinancialRatio(item['Asking Price'], item['TTM Revenue'])}</TableCell>
        <TableCell className="text-right">{calculateFinancialRatio(item['Asking Price'], item['TTM Profit'])}</TableCell>
        <TableCell>
          <a href={item['marketplace-card href']} target="_blank" rel="noopener noreferrer">
            <ExternalLink className="h-4 w-4" />
          </a>
        </TableCell>
        <TableCell>
          <Button variant="ghost" size="sm" onClick={() => onRemove(item.id)}>
            <Trash2 className="h-4 w-4" />
          </Button>
        </TableCell>
      </TableRow>
    );
  }, [data, onRemove]);

  return (
    <div style={{ height: '400px' }}>
      <AutoSizer>
        {({ height, width }) => (
          <List
            height={height}
            itemCount={data.length}
            itemSize={ROW_HEIGHT}
            width={width}
          >
            {Row}
          </List>
        )}
      </AutoSizer>
    </div>
  );
};

export default React.memo(VirtualTable);
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/hooks/useDebounce.js
```js
import { useCallback } from 'react';

export const useDebounce = (callback, delay) => {
  let timeoutId;

  return useCallback((...args) => {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }

    timeoutId = setTimeout(() => {
      callback(...args);
    }, delay);
  }, [callback, delay]);
};
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/hooks/useTableData.js
```js
import { useState, useMemo, useCallback } from 'react';

export const useTableData = (data, initialPageSize = 25) => {
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize, setPageSize] = useState(initialPageSize);
  const [sortConfig, setSortConfig] = useState({ key: null, direction: 'ascending' });

  const totalPages = Math.ceil(data.length / pageSize);
  const startIndex = (currentPage - 1) * pageSize;
  const endIndex = startIndex + pageSize;

  const sortedData = useMemo(() => {
    if (!sortConfig.key) return data;

    return [...data].sort((a, b) => {
      if (a[sortConfig.key] < b[sortConfig.key]) {
        return sortConfig.direction === 'ascending' ? -1 : 1;
      }
      if (a[sortConfig.key] > b[sortConfig.key]) {
        return sortConfig.direction === 'ascending' ? 1 : -1;
      }
      return 0;
    });
  }, [data, sortConfig]);

  const currentPageData = useMemo(() => {
    return sortedData.slice(startIndex, endIndex);
  }, [sortedData, startIndex, endIndex]);

  const handlePageChange = useCallback((page) => {
    setCurrentPage(page);
  }, []);

  const handlePageSizeChange = useCallback((newSize) => {
    setPageSize(newSize);
    setCurrentPage(1);
  }, []);

  const handleSort = useCallback((key) => {
    setSortConfig((prevConfig) => ({
      key,
      direction:
        prevConfig.key === key && prevConfig.direction === 'ascending'
          ? 'descending'
          : 'ascending',
    }));
  }, []);

  return {
    currentPageData,
    currentPage,
    pageSize,
    totalPages,
    totalRecords: data.length,
    sortConfig,
    handlePageChange,
    handlePageSizeChange,
    handleSort,
  };
};
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/App.jsx
```jsx
import React from 'react';
import { BrowserRouter as Router, Route, Routes } from 'react-router-dom';
import Dashboard from './components/Dashboard';
import FileManagement from './components/FileManagement';
import Sidebar from './components/Sidebar';
import ErrorBoundary from './components/ErrorBoundary';
import { DashboardProvider } from './context/DashboardContext';
import { TooltipProvider } from './components/ui/tooltip';
import './index.css';

const Layout = ({ children }) => (
  <div className="flex h-screen bg-white">
    <Sidebar />
    <main className="flex-1 overflow-x-hidden overflow-y-auto">
      {children}
    </main>
  </div>
);

export default function App() {
  return (
    <ErrorBoundary>
      <TooltipProvider>
        <Router>
          <DashboardProvider>
            <div className="App">
              <Layout>
                <Routes>
                  <Route path="/" element={<Dashboard />} />
                  <Route path="/file-management" element={<FileManagement />} />
                </Routes>
              </Layout>
            </div>
          </DashboardProvider>
        </Router>
      </TooltipProvider>
    </ErrorBoundary>
  );
}
```

File: /Users/petercorreia/workspace/updated_acquire_dashboard/src/hooks/useChartData.js
```js
import { useState, useEffect, useCallback } from 'react';

const CHUNK_SIZE = 100;

export const useChartData = (data) => {
  const [chartData, setChartData] = useState([]);
  const [isLoading, setIsLoading] = useState(true);

  const loadChunk = useCallback((startIndex) => {
    return new Promise((resolve) => {
      setTimeout(() => {
        const chunk = data.slice(startIndex, startIndex + CHUNK_SIZE);
        resolve(chunk);
      }, 0);
    });
  }, [data]);

  const loadData = useCallback(async () => {
    setIsLoading(true);
    const chunks = [];
    for (let i = 0; i < data.length; i += CHUNK_SIZE) {
      const chunk = await loadChunk(i);
      chunks.push(...chunk);
      setChartData(prevData => [...prevData, ...chunk]);
    }
    setIsLoading(false);
  }, [data, loadChunk]);

  useEffect(() => {
    setChartData([]);
    loadData();
  }, [loadData]);

  return { chartData, isLoading };
};
```
</file_contents>



</existing_code>

Here is the new feature request:
<feature_request>
<feature_specification>
    <business_requirements>
        <user_story>
            As a user, I want to select multiple uploaded files from the File Management tab so that the
            dashboard updates automatically with the latest metrics and data table for the chosen files.
        </user_story>
        
        <acceptance_criteria>
            <criterion>The "Uploaded Files" list displays each file with a selectable control (e.g., checkbox).</criterion>
            <criterion>Selecting multiple files updates the dashboard's metrics and data table without additional user actions.</criterion>
            <criterion>The dashboard shows a loading indicator while updating metrics and data tables.</criterion>
            <criterion>If no files are selected, the dashboard displays a prompt (e.g., "No files selected" message).</criterion>
        </acceptance_criteria>
        
        <business_rules>
            <rule>The user must be able to select one or more files from the existing list.</rule>
            <rule>Changes in file selection should trigger immediate updates (no explicit "Apply" button).</rule>
            <rule>The solution should scale to handle a large number of uploaded files efficiently.</rule>
            <rule>The feature must not break existing file upload functionality.</rule>
        </business_rules>
    </business_requirements>

    <technical_requirements>
        <component_structure>
            <component name="FileManagementSection">Displays a list of uploaded files with checkboxes.</component>
            <component name="FileItem">Renders individual file entry with a checkbox.</component>
            <component name="Dashboard">Displays metrics and data table.</component>
            <component name="MainLayout">Manages state for selected files and passes data down to Dashboard.</component>
        </component_structure>
        
        <state_management>
            <hook>useState in the parent component for storing array of selected file IDs</hook>
            <hook>useEffect to trigger data fetching when selectedFiles changes</hook>
            <hook>useMemo for optimizing derived data calculations</hook>
            <hook>useRef for tracking previous selections (optional)</hook>
        </state_management>
        
        <props_interface>
            <component name="FileItem">
                <prop>fileId: string</prop>
                <prop>fileName: string</prop>
                <prop>isSelected: boolean</prop>
                <prop>onSelect: (fileId: string, selected: boolean) => void</prop>
            </component>
            <component name="Dashboard">
                <prop>selectedFiles: string[]</prop>
                <prop>metricsData: MetricsType</prop>
                <prop>tableData: TableDataType</prop>
                <prop>isLoading: boolean</prop>
            </component>
        </props_interface>

        <styling>
            <layout_classes>
                <class name="file_list_container">flex flex-col space-y-2 p-4</class>
                <class name="file_item">flex items-center space-x-2 p-2 border-b border-gray-200</class>
                <class name="dashboard_container">p-4 flex flex-col space-y-4</class>
            </layout_classes>
            
            <responsive_design>
                <breakpoint name="small">flex flex-col</breakpoint>
                <breakpoint name="medium">md:flex-row md:space-x-4</breakpoint>
            </responsive_design>
            
            <custom_styles>
                <style name="selected_file">bg-blue-50</style>
                <style name="loading_indicator">animate-spin text-gray-500</style>
            </custom_styles>
        </styling>

        <api_requirements>
            <requirement>Integration with existing API endpoints for metrics and table data</requirement>
            <requirement>Handle loading and error states</requirement>
        </api_requirements>

        <performance_requirements>
            <requirement>Debounce or batch API requests for multiple selections</requirement>
            <requirement>Memoize components to avoid unnecessary re-renders</requirement>
            <requirement>Maintain UI responsiveness with large file selections</requirement>
        </performance_requirements>
    </technical_requirements>

    <validation>
        <test_scenarios>
            <scenario>Select a single file and verify dashboard updates</scenario>
            <scenario>Select multiple files and confirm data aggregation</scenario>
            <scenario>Deselect all files and verify empty state</scenario>
            <scenario>Rapid selection/deselection for UI responsiveness</scenario>
        </test_scenarios>
        
        <edge_cases>
            <case>Empty "Uploaded Files" list</case>
            <case>Large number of files selected (hundreds)</case>
            <case>API errors or empty data sets</case>
            <case>Slow network conditions</case>
        </edge_cases>
        
        <performance_metrics>
            <metric>Dashboard updates within 2 seconds after selection changes</metric>
            <metric>Minimal FPS drop during file selection operations</metric>
        </performance_metrics>
    </validation>
</feature_specification></feature_request>


Before providing your response, analyze the request in your scratchpad:
1. Check compatibility with existing features
2. Identify potential component reuse opportunities
3. Consider state management needs
4. Plan the component hierarchy
5. Consider styling consistency with existing components

Write your analysis in <scratchpad> tags.

Then,provide your complete response in <answer> tags, structured as follows:

1. Component Structure
- Parent/child relationships
- Props interface
- State management approach

2. Styling Approach
- Tailwind class recommendations
- Custom style requirements (if any)
- Responsive design considerations

3. Implementation Details
- Step-by-step implementation guide
- Code snippets for key functionality
- Integration points with existing features

4. Testing Considerations
- Unit test requirements
- Integration test scenarios
- Edge cases to consider

Your response should be detailed enough for a React developer to implement the feature while
maintaining consistency with the existing codebase. Include specific Tailwind classes and React
patterns that align with modern best practices. 

Do not include theoretical alternatives or options - provide a output that should be entire new code files or if there are code updates to existing files then provide the entire code file with the updates. Make sure you are not being lazy in your response and use the maximum amount of output tokens.

Begin your analysis now.